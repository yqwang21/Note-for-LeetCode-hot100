# LeetCode hot100



## 1 哈希

### 1.1 两数之和

<img src="hot100记录.assets\image-20240323094525949.png" alt="image-20240323094525949" style="zoom:80%;" />

使用哈希表记录已经访问过的数值`nums[i]`和下标`i`的映射关系，每新访问一个数值，就在哈希表中查询是否存在与其相加和为`target`的记录。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++){
            // 查看是否遍历过目标值
            auto t = map.find(target - nums[i]);
            if(t != map.end()){
                return {t->second, i};
            }
            map.insert({nums[i], i});
        }
        return {};
    }
};
```

> `unordered_map`常见用法（后续补充）

1. `find`：返回一个迭代器，指向查找到的元素。如果指定的键不存在，`find`函数返回的迭代器等于`end()`

```c++
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> my_map = {
        {1, "one"},
        {2, "two"},
        {3, "three"}
    };

    auto it = my_map.find(2);
    if (it != my_map.end()) {
        std::cout << "The value of key 2 is " << it->second << std::endl;
    } else {
        std::cout << "Key 2 not found" << std::endl;
    }

    it = my_map.find(4);
    if (it != my_map.end()) {
        std::cout << "The value of key 4 is " << it->second << std::endl;
    } else {
        std::cout << "Key 4 not found" << std::endl;
    }

    return 0;
}

```

运行上面的程序，输出结果为

```
The value of key 2 is two
Key 4 not found
```

2. `count`：返回值为找到的元素的个数

在`unordered_map`中，存在元素则返回`1`，反之，返回`0`

```c++
 unordered_map<int,int> map;
 map[0]=1;
 if((map.count(0))
 printf("这个map中含有键为1的键值对");
```



### 1.2 字母异位词分组

<img src="hot100记录.assets\image-20240323100425299.png" alt="image-20240323100425299" style="zoom:80%;" />

将字符串按照字典序排序之后的结果作为索引，并将该索引对应一个记录具有相同索引的字符串数组。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        unordered_map<string, vector<string>> map;
        for(auto str: strs){
            string tmp = str;
            // 对str升序排序，获取对应的索引
            sort(tmp.begin(), tmp.end());
            // 在索引对应的字符串数组中增加该str
            map[tmp].push_back(str);
        }

        vector<vector<string>> ans;
        for(auto kk = map.begin(); kk != map.end(); kk++){
            ans.push_back(kk->second);
        }

        return ans;
    }
};
```

> `sort`的使用

需要头文件`#include <algorithm>`

默认排序为升序，可以自定义比较函数，例如，按照下面的方法可以实现对`a`降序排序：

```c++
bool cmp(int x, int y){
    return x > y;
}

sort(a.begin(), a.end(), cmp);

// 或者下面这种方式
sort(a.begin(), a.end(), greater<int>());
```



### 1.3 最长连续序列

<img src="hot100记录.assets\image-20240323101538460.png" alt="image-20240323101538460" style="zoom:80%;" />

> 官方题解

利用`unordered_set`对原`nums`数组进行去重，然后遍历所有情况

进行的剪枝操作：只有当前元素是连续序列的第一个值才进行往后遍历，使得每个元素最多遍历一次

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 构建num_set，进行去重
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            // 判断该num是否为上升序列的第一个元素，从而保证每个元素只遍历一次
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```

> 个人思路

对原数组进行排序，并去重

依次遍历所有元素，获得最大长度

```c++
class Solution {
public:   
    int longestConsecutive(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        // 对原数组进行排序
        sort(nums.begin(), nums.end());
        // 去重
        vector<int> new_nums;
        for(int i = 0; i < nums.size(); i++){
            if(!i || nums[i] != nums[i - 1])
                new_nums.push_back(nums[i]);
        }

        // 依次遍历所有元素
        int ans = 1, ans_cur = 1;
        for(int i = 1; i < new_nums.size(); i++){
            if(new_nums[i] == new_nums[i - 1] + 1){
                ans_cur++;
            }
            else{
                ans = max(ans, ans_cur);
                ans_cur = 1;
            }
        }
        ans = max(ans, ans_cur);
        return ans;
    }
};
```



## 2 双指针

### 2.1 移动零

<img src="hot100记录.assets\image-20240323102931980.png" alt="image-20240323102931980" style="zoom:80%;" />

利用快慢指针，对于快指针而言：

+ 遇到`0`，跳过
+ 遇到非`0`，将该值记录到慢指针所指下标位置，慢指针移动一位

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 利用快慢指针进行赋值
        int sp = 0; 
        for(int fp = 0; fp < nums.size(); fp++){
            // 非零则记录，零则跳过
            if(nums[fp]){
                nums[sp++] = nums[fp];
            }
        }
       // 将慢指针后续的位置全置为0
        while(sp < nums.size())
            nums[sp++] = 0;
        return;
    }
};
```



### 2.2 盛水最多的容器

<img src="hot100记录.assets\image-20240323103312630.png" alt="image-20240323103312630" style="zoom:80%;" />

<img src="hot100记录.assets\image-20240323103331350.png" alt="image-20240323103331350" style="zoom:80%;" />

左右指针`l, r`位于数组的左右两端，依次移动对应高度较小的指针（`l++`或者`r--`），并记录每次移动后的容积，直到两个指针相遇。

感觉这个思路有贪心的思想，因为若移动高度较高的指针，移动后的面积肯定小于移动前的面积，但如果移动高度较小的指针，移动后的面积可能增加。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int res = 0;
        // 循环直到两个指针相遇
        while(l < r){
            // 计算当前容器面积，更新res
            res = max(res, min(height[l], height[r]) * (r - l));
            // 移动对应高度较小的指针
            if(height[l] < height[r])   
                l++;
            else
                r--;
        }
        return res;
    }
};
```



### 2.3 接雨水

<img src="hot100记录.assets\image-20240323104113234.png" alt="image-20240323104113234" style="zoom:80%;" />

> 双指针法

按列计算每个宽度为1的底能接多少雨水

从图中可以看出，每列的雨水高度取决于该列左边最高的柱子和右边最高柱子的高度的最小值。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2) return 0;
        // maxLeft[i]表示下标i左边（包括本身）的最大高度
        vector<int> maxLeft(height.size(), 0);
        // maxRight[i]表示下标i右边（包括本身）的最大高度
        vector<int> maxRight(height.size(), 0);

        maxLeft[0] = height[0];
        for(int i = 1; i < height.size(); i++)
            maxLeft[i] = max(maxLeft[i - 1], height[i]);

        maxRight[height.size() - 1] = height[height.size() - 1];
        for(int i = height.size() - 2; i >= 0; i--)
            maxRight[i] = max(maxRight[i + 1], height[i]);

        int res = 0;
        for(int i = 0; i < height.size(); i++){
            int curHeight = min(maxLeft[i], maxRight[i]);
            // 这个判断删去也可以，因为统计最大高度时包括了本身
            // 加0对最终的结果也没有影响
            if(curHeight > height[i]){
                res += curHeight - height[i];
            }
        }
        return res;
    }
};
```

> 单调栈法

<img src="hot100记录.assets\image-20240323105851338.png" alt="image-20240323105851338" style="zoom:80%;" />

维护一个从栈顶到栈底是严格递增的单调栈

+ 遇到小于栈顶元素高度的元素时，将该元素入栈，因为需要大于等于才能接雨水

  ```c++
  if(height[i] < height[st.top()]) st.push(i);
  ```

+ 遇到等于栈顶元素高度的元素时，替换栈顶元素，例如两个连着的高为2的柱子，在计算雨水体积时，需要用靠右的柱子

  ```c++
  if(height[i] == height[st.top()]){
      st.pop();
      st.push(i);
  }
  ```

+ 遇到大于栈顶元素高度的元素时，弹出栈顶元素，该元素为接雨水凹槽的底，此时剩余的栈顶元素为接雨水凹槽的左边界

  ```c++
  // while循坏，需要持续计算
  while(!st.empty() && height[i] >= height[st.top()]){
      int mid = st.top();
      st.pop();
      if(!st.empty()){
          int h = min(height[i], height[st.top()]) - height[mid];
          // 注意减1，因为需要求左右边界中间的宽度
          int w = i - st.top() - 1;
          res += h * w;
      }
  }
  st.push(i);
  ```

整合后的代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int res = 0;
        for(int i = 0; i < height.size(); i++){
            while(!st.empty() && height[i] >= height[st.top()]){
                int mid = st.top();
                st.pop();
                if(!st.empty()){
                    int h = min(height[i], height[st.top()]) - height[mid];
                    int w = i - st.top() - 1;
                    res += h * w;
                }
            }
            st.push(i);
        }
        return res;
    }
};
```



## 3 滑动窗口

### 3.1 无重复字符串的最长子串

<img src="hot100记录.assets\image-20240323125540586.png" alt="image-20240323125540586" style="zoom:80%;" />

> 个人思路

用`unordered_map`记录对应字符上一次出现的位置，若新加入的字符在之前出现过，则更新窗口左端点的位置。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // map用于记录s[i]以及其上一次出现的位置的下标
        unordered_map<char, int> map;
        // res记录最终答案，cur_res记录当前窗口长度
        int res = 0, cur_res = 0;
        for(int i = 0; i < s.size(); i++){
            // 若s[i]之前未出现，则将s[i]移动进窗口
            if(map.find(s[i]) == map.end()){
                // 当前窗口长度 +1
                cur_res++;
                map[s[i]] = i;
            }
            // 若s[i]之前出现过
            else{
                // 窗口需要更新，更新res
                res = max(res, cur_res);
                // 若s[i]上一次出现的位置不在当前窗口内，则 cur_res += 1
                // 若s[i]上一次出现的位置不在当前窗口内，则 cur_res = i - map[s[i]]
                // 那么如何判断s[i]上一次出现是否在窗口内呢？对上述两式取min即可
                cur_res = min(cur_res + 1, i - map[s[i]]);
                // 并对map[s[i]]进行更新
                map[s[i]] = i;
            }
        }
        res = max(res, cur_res);
        return res;
    }
};
```

> 官方题解

个人思路里面对更新`cur_res`的思路有点绕，我也是样例出现报错才发现需要对`s[i]`上一次出现是否在窗口内进行特判。

官方题解的思路就比较常规，用`unodered_set`来记录在窗口中的字符

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希集合，记录每个字符是否出现过
        unordered_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            }
            // 只要下一个元素未在窗口中出现，就将该元素加入窗口
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                occ.insert(s[rk + 1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }
};
```



### 3.2 找到字符串中所有字母异位词

<img src="hot100记录.assets\image-20240323132527993.png" alt="image-20240323132527993" style="zoom:80%;" />

统计出字符串`p`中各个字符的出现次数

在字符串`s`中取与字符串`p`相同长度的窗口，移动窗口，并统计窗口中各个字符出现的次数，并与字符串`p`中各个字符出现的次数作比较

```c++
class Solution {
public:
    // 词频比较函数
    bool cmpstr(int a[26], int b[26]){
        for(int i = 0; i < 26; i++){
            if(a[i] != b[i]) return false;
        }
        return true;
    }
    
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;

        if(s.size() < p.size()) return res;

        // 因为题中只含有小写字母，所以用长度为26的数组做词频统计
        int countp[26] = {0};
        int counts[26] = {0};
        for(int i = 0; i < p.size(); i++){
            countp[p[i] - 'a']++;
        }

        int len = p.size(), lens = s.size();
        int l = 0, r = -1;
        // 移动窗口右端点
        while(r < lens - 1){
            r++;
            counts[s[r] - 'a']++;
            // 保证窗口长度等于字符串p的长度
            if(r - l + 1 > len){
                counts[s[l] - 'a']--;
                l++;
            }
            if(r - l + 1 == len)
                if(cmpstr(countp, counts))
                    res.push_back(l);
        }
        return res;
    }
};
```



## 4 子串

### 4.1 和为K的子数组

<img src="hot100记录.assets\image-20240323133806008.png" alt="image-20240323133806008" style="zoom:80%;" />

**子数组是数组中元素的连续非空序列**

+ 首先尝试了暴力枚举（超时）
+ 因为是计算连续元素的和，想到用**前缀和**，利用前缀和之后可以ac，但是耗时较长
+ 最终思路：**前缀和+哈希表**

哈希表为不同前缀和的数值与出现次数的映射，但这个方法需要保证每次只在该数之前的前缀和中搜索（边遍历边计算）：

假设`nums[1] ~ nums[6]`和`nums[1] ~ nums[9]`的前缀和都为`5`，而`nums[1] ~ nums[8]`前缀和为`8`，`target`为`3`：

+ 如果先遍历一边统计完所有的前缀和数值以及出现次数，前缀和为`5`出现了2次。在第二次遍历到`nums[8]`时，会将`res += 2`，但实际上`nums[8] ~ nums[9]`的和为`-3`，并不符合题意

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // 用前缀和+哈希表进行优化，这个方法必须保证每次只在该数之前的前缀和中搜索
        // map: 前缀和数值 --> 出现次数
        unordered_map<int, int> map;
        // 前缀和为0先初始化为1，使得第一个元素可以参与求和
        map[0] = 1;

        int res = 0;
        int pre = 0;
        for(int i = 1; i <= nums.size(); i++){
            pre += nums[i - 1];
            int target = pre - k;
            // 查看目标前缀和是否出现过
            if(map.find(target) != map.end()){
                res += map[target];
            }
            map[pre]++;
        }
        return res;
    }
};
```



### 4.2 滑动窗口最大值

<img src="hot100记录.assets\image-20240323135354008.png" alt="image-20240323135354008" style="zoom:80%;" />

**这是单调队列的一道典型题！！！！**

通过代码理解滑动窗口的思路：

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        // 需要一个双向队列来维护从队头到队尾单调非严格单调递减的单调队列
        deque<int> dq;
        // 将前k个元素进行对应的入队操作
        for(int i = 0; i < k; i++){
            while(!dq.empty() && nums[dq.back()] <= nums[i]){
                dq.pop_back();
            }
            dq.push_back(i);
        }

        for(int i = k; i < nums.size(); i++){
            result.push_back(nums[dq.front()]);
            
            // 判断是否有元素需要出队
            if(dq.front() < i - k + 1){
                dq.pop_front();
            }

            // 元素入队
            while(!dq.empty() && nums[dq.back()] <= nums[i]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        result.push_back(nums[dq.front()]);

        return result;
    }
};
```



### 4.3 最小覆盖子串

<img src="hot100记录.assets\image-20240323140134772.png" alt="image-20240323140134772" style="zoom:80%;" />

+ `i`作为窗口右端点，每次循环向右移动一位
+ `j`作为窗口的左端点，出现冗余字符串时，向右移动

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        // cntt 统计t中字符出现次数
        // snts 统计s的当前窗口中字符出现的次数
        unordered_map<char, int> cntt, cnts;
        
        for(int i = 0; i < t.size(); i++){
            cntt[t[i]]++;
        }

        string ans = "";

        // i为窗口右端点，每次循环向右移动一步
        // j为窗口左端点
        // cnt记录窗口中有效字符出现的次数
        for(int i = 0, j = 0, cnt = 0; i < s.size(); i++){
            // 添加当前字符，更新有效字符数量
            cnts[s[i]]++;
            if(cnts[s[i]] <= cntt[s[i]]) cnt++;

            // j向右移动，去除冗余字符
            while(cnts[s[j]] > cntt[s[j]]){
                cnts[s[j]]--, j++;
            }
            
			// 如果当前窗口已经完全覆盖t，更新ans
            if(cnt == t.size()){
                if(ans == "" || ans.size() > i - j + 1){
                    ans = s.substr(j, i - j + 1);
                }
            }
        }

        return ans;
    }
};
```

> 上述代码中存在一个问题，`unordered_map`访问未出现的`key`会出现什么情况：

```c++
unordered_map<string, int> mymap1;  
auto val = mymap1["str"]; // val为0   

// 常用于词频统计，存在则加一，不存在则创建后赋值为1 
unordered_map<string, int> mymap2;  
mymap2["str"]++; // mymap2["str"] = 1   
```

Map中使用方括号访问键对应的值`map[key]`时：

+ 若该`key`存在，则访问取得`value`值；

+ 若该`key`不存在，访问仍然成功，取得`value`对象默认构造的值。具体如下：

  用` []`访问，但`key`不存在时，**C++会利用该`key`及默认构造的`value`，组成`{key，value}`对，插入到`map`中**。

  `value`为 `string`对象，则构造空串；`value`为`int`对象，构造为`0`。

注：因此在访问`map`元素时，应先用`map.find`查找该元素，找到后再访问。 同时，用法`mymap2["str"]++;`常用于词频统计，存在则加一，不存在则创建后赋值为`1`。



## 5 普通数组



### 5.1 最大子数组和

<img src="hot100记录.assets/image-20240324181240741.png" alt="image-20240324181240741" style="zoom:80%;" />

> 动态规划（第一反应的思路）

`dp[i]`表示以`nums[i]`结尾的最大连续子数组的和

+ 若`dp[i - 1] < 0`，则需要从`nums[i]`开始的新的子数组，`dp[i] = nums[i]`
+ 若`dp[i - 1] > 0`，则可以将`nums[i]`接在之前的子数组后面，即`dp[i] = dp[i - 1] + nums[i]`

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {    
        vector<int> dp(nums.size(), 0);

        dp[0] = nums[0];
        int result = dp[0];

        for(int i = 1; i < nums.size(); i++){
            dp[i] = max(dp[i - 1], 0) + nums[i];
            if(dp[i] > result){
                result = dp[i];
            }
        }
        return result;
    }
};
```



> 前缀和（来自灵茶山艾府）

由于数组的元素和等于两个前缀和的差，所以求出`nums`的前缀和，通过一次遍历，每次都减去之前遍历过的最小的前缀和即可知道以`nums[i]`结尾的子数组的最大和

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int min_prefixSum = 0, prefixSum = 0;
        for(int i = 0; i < nums.size(); i++){
            prefixSum += nums[i];
            ans = max(ans, prefixSum - min_prefixSum);
            min_prefixSum = min(prefixSum, min_prefixSum);
        }
        return ans;
    }
};
```



> 分治（力扣官方题解）

定义一个操作`get(a, l, r)`表示查询`a`序列`[l, r]`区间内的最大子段和，那么最终求的答案就应该是`get(nums, 0, nums.size() - 1)`。

对区间`[l, r]`进行分治求解，分为两个区间`[l, mid]`（左子区间）和`[mid + 1, r]`（右子区间），其中`mid = (l + r) >> 1`。分治不断向下递归到区间长度为1时，向上返回。

在整个分治过程中，需要维护以下四个量：

+ `lSum`：区间`[l, r]`内以`l`为左端点的最大子段和 

  --> {左子区间的`lSum`} 与 {左子区间的`iSum`和右子区间的`lSum`的和} 的最大值

+ `rSum`：区间`[l, r]`内以`r`为右端点的最大子段和

  --> {右子区间的`rSum`} 与 {右子区间的`iSum`和左子区间的`rSum`的和} 的最大值

+ `mSum`：区间`[l, r]`的最大子段和

  --> {左子区间的`mSum`} 与 {右子区间的`mSum`} 与 {左子区间的`rSum`和右子区间的`lSum`的和} 的最大值

+ `iSum`：区间`[l, r]`的和

  --> {左子区间的`iSum`} + {右子区间的`iSum`}

```c++
class Solution {
public:
    struct Status {
        int lSum, rSum, mSum, iSum;
    };

    Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        int lSum = max(l.lSum, l.iSum + r.lSum);
        int rSum = max(r.rSum, r.iSum + l.rSum);
        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);
        return (Status) {lSum, rSum, mSum, iSum};
    };

    Status get(vector<int> &a, int l, int r) {
        if (l == r) {
            return (Status) {a[l], a[l], a[l], a[l]};
        }
        int m = (l + r) >> 1;
        Status lSub = get(a, l, m);
        Status rSub = get(a, m + 1, r);
        return pushUp(lSub, rSub);
    }

    int maxSubArray(vector<int>& nums) {
        return get(nums, 0, nums.size() - 1).mSum;
    }
};
```



### 5.2 合并区间

<img src="hot100记录.assets/image-20240324184234967.png" alt="image-20240324184234967" style="zoom:80%;" />

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        // 将区间按照左端点从小到大排序
        sort(intervals.begin(), intervals.end());
        // l, r分别记录当前维护的区间的左右端点
        int l = intervals[0][0], r = intervals[0][1];
        for(int i = 1; i < intervals.size(); i++){
            int cur_l = intervals[i][0], cur_r = intervals[i][1];
            // 当前区间与所维护的区间有交集
            if(cur_l <= r){
                // 更新当前需维护的区间的右端点
                r = max(cur_r, r);
            }
            // 当前区间与所维护的区间之间没有交集
            else{
                // 当前维护的区间加入结果集
                result.push_back({l, r});
				// 当前区间更新成需要维护的区间
                l = cur_l, r = cur_r;
            }
        }
        // 别忘了把最后维护的区间加入结果集
        result.push_back({l, r});

        return result;
    }
};
```



### 5.3 轮转数组

<img src="hot100记录.assets/image-20240324184755325.png" alt="image-20240324184755325" style="zoom:80%;" />

> 直接映射

这个思路比较常规，但需要额外申请数组

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> result(n, 0);
        for(int i = 0; i < n; i++){
            result[(i + k) % n] = nums[i];
        }
        nums = result;
    }
};
```



> 分段逆序

这个思路感觉比较巧妙，直接拿一个例子做一遍就可以理解。

```c++
class Solution {
public:
    // 逆序函数
    void reverse(vector<int>& nums, int l, int r){
        while(l < r){
            swap(nums[l], nums[r]);
            l++, r--;
        }
    }
    
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        // 别忘了将 k 对 n 取模
        k = k % n;
        // 将所有序列逆序
        reverse(nums, 0, n - 1);
        // 将分段点两端数组再一次分别逆序
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
};
```



### 5.4 除自身以外数组的乘积

<img src="hot100记录.assets/image-20240324185320064.png" alt="image-20240324185320064" style="zoom:80%;" />

感觉像是从左到右计算一次“前缀积”（不确定有没有这个名字），然后再从右往左计算一次“前缀积”，再相乘。

下面的代码有一个优化，使得只需要额外申请一个与`nums`长度相同的数组即可（原来需要申请两个）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> res(nums.size());
        
        // 从左往右计算一次前缀积
        res[0] = 1;
        for(int i = 1; i < nums.size(); i++){
            res[i] = res[i - 1] * nums[i - 1];
        }
        // 从右往左计算
        int right = 1;
        for(int i = nums.size() - 1; i >= 0; i--){
            res[i] *= right;
            right *= nums[i];
        }
        return res;
    }
};
```



### 5.5 缺失的第一个正数

<img src="hot100记录.assets/image-20240324185949723.png" alt="image-20240324185949723" style="zoom:80%;" />

> 过于巧妙的思路

感觉像智商题（我承认自己智商不够）

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        // 对于一个长度为n的数组，其中未出现的最小整数一定在[1, n+1]之间
        // 这一点只能说太妙了
        vector<int> cnt(nums.size() + 2, 0);
        // 统计 1 ~ n + 1中各个数出现的次数
        int n = nums.size() + 1;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > 0 && nums[i] <= n){
                cnt[nums[i]] ++;
            }
        }
        int res = 0;
        for(int i = 1; i < n + 1; i++){
            if(cnt[i] == 0){
                res = i;
                break;
            }
        }
        return res;
    }
};
```



>替换法

感觉这个思路还是考虑了上一个思路中的——对于一个长度为`n`的数组，其中未出现的最小整数一定在`[1, n+1]`之间

对于`nums[i]`，若其在区间`[1, n + 1]`中，则将其放到下标为`nums[i] - 1`的位置。再遍历一次时，第一个出现异常的位置就是未出现的最小的数。

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < nums.size(); i++){
            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){
                swap(nums[nums[i] - 1], nums[i]);
            }
        }

        for(int i = 0; i < n; i++)
            if(nums[i] != i + 1)
                return i + 1;
        
        return n + 1;
    }
};
```



## 6 矩阵 



### 6.1 矩阵置零

<img src="hot100记录.assets/image-20240324191150453.png" alt="image-20240324191150453" style="zoom:80%;" />

这一题需要注意的一点是，不能遇到`0`就直接将该`0`所在行、所在列都置为`0`，这种做法会导致一些不该置为`0`的位置被置为`0`。

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        // col[i] == 1 表示第i列需要被置为0，row的效果类似
        vector<int> col(matrix[0].size(), 0);
        vector<int> row(matrix.size(), 0);

        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0; j < matrix[i].size(); j++){
                if(matrix[i][j] == 0){
                    row[i] = col[j] = 1;
                }
            }
        }
        for(int i = 0; i < col.size(); i++){
            if(col[i] == 1){
                for(int j = 0; j < matrix.size(); j++)
                    matrix[j][i] = 0;
            }
        }
        for(int i = 0; i < row.size(); i++){
            if(row[i] == 1){
                for(int j = 0; j < matrix[i].size(); j++)
                    matrix[i][j] = 0;
            }
        }
    }
};
```



### 6.2 旋转矩阵

<img src="hot100记录.assets/image-20240324191716619.png" alt="image-20240324191716619" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324191739788.png" alt="image-20240324191739788" style="zoom:80%;" />

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 这个思路真的很妙
        // 遍历完某一列或某一行之后，就将对应的上下左右范围往里缩
        // 这个做法不会导致区间问题
        int l = 0, r = matrix[0].size() - 1;
        int up = 0, down = matrix.size() - 1;

        vector<int> res;

        while(true){

            for(int i = l; i <= r; i++){
                res.push_back(matrix[up][i]);
            }
            if(++up > down) break;

            for(int i = up; i <= down; i++){
                res.push_back(matrix[i][r]);
            }
            if(--r < l) break;

            for(int i = r; i >= l; i--){
                res.push_back(matrix[down][i]);
            }
            if(--down < up) break;

            for(int i = down; i >= up; i--){
                res.push_back(matrix[i][l]);
            }
            if(++l > r) break;
        }
        return res;
    }
};
```



### 6.3 旋转图像

<img src="hot100记录.assets/image-20240324192015046.png" alt="image-20240324192015046" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324192024422.png" alt="image-20240324192024422" style="zoom:80%;" />

主要考察旋转的坐标变换吧，临时推一下就行。

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 这题主要考察旋转之后坐标的变换
        
        int n = matrix.size();

        for(int i = 0; i < n / 2; i++){            
            for(int j = i; j < n - 1 - i; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
};
```



### 6.4 搜索二维矩阵II

<img src="hot100记录.assets/image-20240324192213060.png" alt="image-20240324192213060" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324192234754.png" alt="image-20240324192234754" style="zoom:80%;" />

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 从右上角开始遍历，当需要更小的值时向左移动，需要更大的值时向下移动
        int i = 0, j = matrix[0].size() - 1;
        int m = matrix.size() - 1, n = matrix[0].size() - 1;
        while(i <= m && j >= 0){
            if(matrix[i][j] < target){
                i++;
            }
            else if(matrix[i][j] > target){
                j--;
            }
            else{
                return true;
            }
        }
        return false;
    }
};
```



## 7 链表



需要记一下单链表结构体的声明，以及构造函数怎么写：

```c++
// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(NULL) {}
    ListNode(int x) : val(x), next(NULL) {}
};
```

如何将输入的数组转换成单链表：

```c++
ListNode* num2list(vector<int>& nums){
    ListNode* dummyhead = new ListNode();
    ListNode* tail = dummyhead;
    for(int i = 0; i < nums.size(); i++){
        ListNode* newNode = new ListNode(nums[i]);
        tail->next = newNode;
        tail = tail->next;
    }
    // return dummyhead;
    return dummyhead->next;
}
```



### 7.1 相交链表

<img src="hot100记录.assets/image-20240324193134435.png" alt="image-20240324193134435" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324193153956.png" alt="image-20240324193153956" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324193206366.png" alt="image-20240324193206366" style="zoom:80%;" />

这题需要注意的一点是，相交不是遍历两个链表直到`node1->val == node2->val`（值相等），而是链表的元素相等，即`node1`和`node2`指向的是同一个地址。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    // 获得链表长度的函数
    int getlen(ListNode *head){
        if(head == NULL) return 0;

        int res = 0;
        ListNode *tmp = head;
        while(tmp){
            res++;
            tmp = tmp->next;
        }
        return res;
    }
    
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getlen(headA), lenB = getlen(headB);

        // 将两个链表右对齐
        ListNode *curA = headA, *curB = headB;
        if(lenA > lenB){
            int cnt = lenA - lenB;
            while(cnt--){
                curA = curA->next;
            }
        }
        else if(lenA < lenB){
            int cnt = lenB - lenA;
            while(cnt--){
                curB = curB->next;
            }
        }
		
        // 依次遍历，直到相交
        while(curA && curB){
            if(curA == curB)
                return curA;
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```



### 7.2 翻转链表

<img src="hot100记录.assets/image-20240324193529283.png" alt="image-20240324193529283" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240324193544767.png" alt="image-20240324193544767" style="zoom:80%;" />

这题的代码可以当做模板背，之后遇到需要翻转链表的操作可以直接用。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head, *pre = NULL;
        while(cur){
            ListNode *Next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = Next;
        }
        return pre;
    }
};
```



### 7.3 回文链表

<img src="hot100记录.assets/image-20240324193800082.png" alt="image-20240324193800082" style="zoom:80%;" />

> 翻转后半部分链表，进行比较

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 链表翻转函数
    ListNode* reverse(ListNode *head){
        ListNode* pre = NULL, *cur = head;
        while(cur){
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    
    bool isPalindrome(ListNode* head) {
        // 利用快慢指针定位中点
        ListNode *fast = head, *slow = head;
        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        slow = slow->next;

        // 将后半部分的链表进行反转，跟前半部分进行对比是否相等
        ListNode *st1 = head, *st2 = reverse(slow);
        while(st2){
            if(st1->val != st2->val)
                return false;
            st1 = st1->next;
            st2 = st2->next;
        }
        return true;
    }
};
```



> 利用堆栈

将前一半的元素值一次入栈，遍历链表后一半时，一边遍历，一边比较是否与栈顶元素相同。

利用栈的原因是先入后出，所以栈中元素出栈顺序应该与后一半链表遍历的顺序是一致的才是回文链表。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 统计链表长度
    int getListLen(ListNode* head){
        int len = 0;
        while(head){
            len++;
            head = head->next;
        }
        return len;
    }
    
    bool isPalindrome(ListNode* head) {
        int len = getListLen(head);
        if(len == 1) return true;

        // 将前一半链表元素入栈
        int halfLen = len >> 1;
        stack<int> st;
        ListNode* cur = head;
        while(halfLen--){
            st.push(cur->val);
            cur = cur->next;
        }
        // 如果链表长度是奇数，最中间元素不需要比较，直接跳过
        if(len % 2 == 1)
            cur = cur->next;

        // 遍历后一半链表，依次比较
        while(cur){
            if(cur->val != st.top())
                return false;
            st.pop();
            cur = cur->next;
        }
        return true;
    }
};
```



### 7.4 环形链表

<img src="hot100记录.assets/image-20240324194843815.png" alt="image-20240324194843815" style="zoom: 80%;" />

<img src="hot100记录.assets/image-20240324194858029.png" alt="image-20240324194858029" style="zoom:80%;" />

定义快慢指针`fast`、`slow`，`fast`每次往后走两步，`slow`每次往后走一步

+ 存在环，则`fast`和`slow`会相遇
+ 不存在环，`fast`会先遍历至`NULL`

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == NULL) return false;
        
        ListNode *slow = head, *fast = head;
        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true;
        }
        return false;
    }
};
```



### 7.5 环形链表II

<img src="hot100记录.assets/image-20240325091007050.png" alt="image-20240325091007050" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325091021755.png" alt="image-20240325091021755" style="zoom:80%;" />

判断是否存在环的方法与上一题相同，唯一的区别是这一题需要找到环的入口。

（思路来自代码随想录）

假设从头结点到环形入口节点的节点数为 $x$。环形入口节点到`fast`指针和`slow`指针相遇节点的节点数为 $y$。从相遇节点到环形入口节点的节点数为 $z$，如下图所示：

<img src="hot100记录.assets/image-20240325091522827.png" alt="image-20240325091522827" style="zoom:80%;" />

那么相遇时：`slow`指针走过的距离为 $x+y$，`fast`指针走过的距离为 $x+ y + n * (y + z)$，其中 $n$为`fast`指针在环中走过的圈数。由于`fast`指针的速度为`slow`指针的$2$倍，所以有：


$$
\begin{align}
& (x + y) \times 2 = x + y + n \cdot (y + z)\\
\Rightarrow & x + y = n\cdot (y + z) \\
\Rightarrow & x = (n - 1) \cdot (y + z) + z
\end{align}
$$


说明，若此时新增一个`cur`指针从头结点出发，速度等于`slow`指针，这两个指针最终将在环形入口处相遇。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(head == NULL) return NULL;
        
        ListNode *fast = head, *slow = head;
        
        bool flag = false;
        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast){
                flag = true;
                break;
            }
        }
        if(flag == false) return NULL;

        ListNode *entry = head;
        while(entry != slow){
            entry = entry->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



### 7.6 合并两个升序链表

<img src="hot100记录.assets/image-20240325092454373.png" alt="image-20240325092454373" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325092507891.png" alt="image-20240325092507891" style="zoom:80%;" />

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *dummyhead = new ListNode();
        // cur1：遍历到list1的哪个节点
        // cur2：遍历到list2的哪个节点
        // cur：遍历到新list的哪个节点
        ListNode *cur1 = list1, *cur2 = list2, *cur = dummyhead;

        while(cur1 && cur2){
            if(cur1->val < cur2->val){
                ListNode *tmp = cur1;
                cur1 = cur1->next;
                tmp->next = cur->next;
                cur->next = tmp;
                cur = tmp;
            }
            else{
                ListNode *tmp = cur2;
                cur2 = cur2->next;
                tmp->next = cur->next;
                cur->next = tmp;
                cur = tmp;               
            }
        }

        // 将list1或list2剩余的节点接到新list中
        if(cur1){
            cur->next = cur1;
        }
        if(cur2){
            cur->next = cur2;
        }
        return dummyhead->next;
    }
};
```



### 7.7 两数相加

<img src="hot100记录.assets/image-20240325092809525.png" alt="image-20240325092809525" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325092821733.png" alt="image-20240325092821733" style="zoom:80%;" />

这题其实是用链表实现高精度加法，而且原始链表本来就是逆序，甚至减少了从数字转换到链表的工作。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		// add1，add2记录当前需要相加的节点
        ListNode *add1 = l1, *add2 = l2;

        ListNode *dummyhead = new ListNode();
        ListNode *cur = dummyhead;
        // t用于记录进位的值
        int t = 0;
        while(add1 || add2){
            if(add1){
                t += add1->val;
                add1 = add1->next;
            }
            if(add2){
                t += add2->val;
                add2 = add2->next;
            }

            ListNode *node = new ListNode(t % 10);
            cur->next = node;
            cur = node;

            t = t / 10;
        }
        
        // 处理剩余的进位
        while(t){
            ListNode *node = new ListNode(t % 10);
            cur->next = node;
            cur = node;

            t = t / 10;            
        }

        return dummyhead->next;
    }
};
```



### 7.8 删除链表的倒数第N个结点

<img src="hot100记录.assets/image-20240325093200252.png" alt="image-20240325093200252" style="zoom:80%;" />

删除链表的倒数第$N$个结点，需要定位倒数第$N + 1$个结点的位置，那么如何定位呢？

使用快慢指针，先使快指针`fast`先走$N + 1$步，然后指针`slow`和指针`fast`以相同的速度往后走，当`fast`指针走到`NULL`（链表尾）时，`slow`指刚好指向倒数第$N + 1$个结点。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyhead = new ListNode();
        dummyhead->next = head;
        
        ListNode *fast = dummyhead, *slow = dummyhead;
        // fast先走 n + 1 步
        for(int i = 0; i <= n; i++){
            fast = fast->next;
        }

        // 定位到倒数第 n + 1 个结点的位置
        while(fast){
            fast = fast->next;
            slow = slow->next;
        }

        // // 感觉最好还是做一下内存释放吧
        // ListNode* tmp = slow->next;
        slow->next = slow->next->next;
        // delete(tmp);

        return dummyhead->next;
    }
};
```



### 7.9 两两交换链表中的节点

<img src="hot100记录.assets/image-20240325093757683.png" alt="image-20240325093757683" style="zoom:80%;" />

这题主要通过画图来模拟交换过程，根据图上的顺序就可以写出代码。

<img src="hot100记录.assets/image-20240325094637159.png" alt="image-20240325094637159" style="zoom:40%;" />

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyhead = new ListNode();
        dummyhead->next = head;
        // cur用于记录需要变换的区间的前一个节点
        ListNode *cur = dummyhead;
        while(cur->next && cur->next->next){
            ListNode *tmp = cur->next->next;
            cur->next->next = tmp->next;
            tmp->next = cur->next;
            cur->next = tmp;
            cur = cur->next->next; 
        }

        return dummyhead->next;
    }
};
```



### 7.10 K个一组翻转链表

<img src="hot100记录.assets/image-20240325094740873.png" alt="image-20240325094740873" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325094754552.png" alt="image-20240325094754552" style="zoom:80%;" />

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转链表指定区间的模板 
    // 将start到tail的链表进行翻转（不包括tail）
    ListNode* reverse(ListNode* start, ListNode* tail){
        ListNode* pre = NULL, *cur = start;
        while(cur != tail){
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummyhead = new ListNode();
        dummyhead->next = head;
        // cur记录需要翻转的区间的前一个节点
        ListNode* cur = dummyhead;
        while(cur){
            // tail记录需要翻转的区间的后一个节点
            ListNode *tail = cur;
            bool flag = true;
            for(int i = 0; i <= k; i++){
                if(tail){
                    tail = tail->next;
                }
                else{
                    flag = false;
                    break;
                }
            }
            if(!flag) break;

            ListNode* start = cur->next;
            ListNode* newstart = reverse(start, tail);
            // 翻转之后start变为区间的尾结点
            cur->next = newstart;
            start->next = tail;
            cur = start;
        }

        return dummyhead->next;
    }
};
```



### 7.11 随机链表的复制

<img src="hot100记录.assets/image-20240325095324179.png" alt="image-20240325095324179" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325095341504.png" alt="image-20240325095341504" style="zoom:80%;" />

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        // 用哈希表存前后链表对应节点
        unordered_map<Node*, Node*> map;

        Node *dummyhead = new Node(-1);
        dummyhead->next = head;
        Node *dummyhead2 = new Node(-1);

        Node *cur = dummyhead->next, *cur2 = dummyhead2;
        // 先完成除了random部分新链表的建立
        while(cur){
            Node *tmp = new Node(cur->val);
            // 记录前后链表对应节点的关系
            map.insert({cur, tmp});
            cur2->next = tmp;
            cur2 = tmp;
            cur = cur->next;

        }
        cur = dummyhead->next, cur2 = dummyhead2->next;
        // 再一次遍历，利用哈希表完成random部分的连接
        while(cur){
            cur2->random = map[cur->random];
            cur = cur->next, cur2 = cur2->next;
        }

        return dummyhead2->next;
    }
};
```



### 7.12 排序链表

<img src="hot100记录.assets/image-20240325095656062.png" alt="image-20240325095656062" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325095709091.png" alt="image-20240325095709091" style="zoom:80%;" />

> 链表的快速排序

以当前链表的中间节点的`val`作为基准，将链表分为三部分

+ `llist`：记录小于中间节点的`val`的节点
+ `elist`：记录等于中间节点的`val`的节点
+ `glist`：记录大于中间节点的`val`的节点

对`llist`和`glist`进行递归的快速排序，并将上述三条链表依次合并

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == NULL|| head->next == NULL) return head;

        // 定位中间节点，并得到基准target
        ListNode* fast = head, *slow = head;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        int target = slow->val;
        
        // 遍历整条链表，获得llist、elist、glist
        ListNode* llist = new ListNode(), * elist = new ListNode(), * glist = new ListNode();
        ListNode* cur = head, *next;
        while(cur){
            next = cur->next;
            if(cur->val == target){
                cur->next = elist->next;
                elist->next = cur;
            }
            else if(cur->val < target){
                cur->next = llist->next;
                llist->next = cur;
            }
            else{
                cur->next = glist->next;
                glist->next = cur;
            }
            cur = next;
        }

        // 对llist、glist进行递归排序
        llist = sortList(llist->next);
        elist = elist->next;
        glist = sortList(glist->next);

        // 将上面的链表合并
        ListNode* dummyhead = new ListNode();
        cur = dummyhead;
        if(llist){
            cur->next = llist;
            while(cur->next){
                cur = cur->next;
            }
        }
        if(elist){
            cur->next = elist;
            while(cur->next){
                cur = cur->next;
            }
        }
        if(glist){
            cur->next = glist;
            while(cur->next){
                cur = cur->next;
            }
        }
        return dummyhead->next;
    }
};
```



> 链表的归并排序

数组的归并排序是从上到下递归到区间长度为1时，再向上进行数组合并；但是对于链表的归并排序，需要直接从下至上进行合并。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 获得链表的长度
        int len = 0;
        for(ListNode* p = head; p; p = p->next) len++;

        // 自底向上进行合并，遍历需要合并的长度
        for(int i = 1; i < len; i *= 2){
            // dummyhead用于指向新的链表，同时也为后续更新head
            ListNode* dummyhead = new ListNode();
            ListNode* cur = dummyhead;
            
            // cnt为需要合并的次数
            // 向上取整是因为需要合并的区间数量存在奇数的情况，最后一段区间也需要合并
            int cnt = ceil(len / 2.0 / i);
            while(cnt--){
                // p1，p2为两个需要合并的区间的头结点
                ListNode* p1 = head, * p2 = head;
                for(int j = 0; j < i && p2; j++)
                    p2 = p2->next;

                // 记录下一组需要合并的区间的头结点
                ListNode* next = p2;
                for(int j = 0; j < i && next; j++)
                    next = next->next;
                
                // 将两个区间进行合并，l1、l2记录两个区间有多少元素已经合并
                int l1 = 0, l2 = 0;
                while(l1 < i && l2 < i && p1 && p2){
                    if(p1->val < p2->val){
                        cur->next = p1;
                        cur = cur->next;
                        p1 = p1->next;
                        l1++;
                    }
                    else{
                        cur->next = p2;
                        cur = cur->next;
                        p2 = p2->next;
                        l2++;
                    }
                }
                while(l1 < i && p1){
                    cur->next = p1;
                    cur = cur->next;
                    p1 = p1->next;
                    l1++;                    
                }
                while(l2 < i && p2){
                    cur->next = p2;
                    cur = cur->next;
                    p2 = p2->next;
                    l2++;                    
                }
                
                // 将head指向下一组区间开头
                head = next;
            }
            // 防止成环
            cur->next = NULL;
            // 更新head
            head = dummyhead->next;
        } 
        return head;
    }
};
```



### 7.13 合并K个升序链表

<img src="hot100记录.assets/image-20240325101842945.png" alt="image-20240325101842945" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325101853891.png" alt="image-20240325101853891" style="zoom:80%;" />

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 自定义比较函数
    struct cmp{
        bool operator()(const ListNode* a, const ListNode* b){
            return a->val > b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size() == 0) return NULL;

        // 利用小顶堆实现
        priority_queue<ListNode*, vector<ListNode*>, cmp> que;
        // 将lists中每个链表的首元素入堆
        for(int i = 0; i < lists.size(); i++){
            if(lists[i] != NULL)
                que.push(lists[i]);
        }

        ListNode* dummyhead = new ListNode();
        ListNode* cur = dummyhead;
        while(!que.empty()){
            // 弹出堆顶元素
            ListNode* tmp = que.top();
            que.pop();
            ListNode* next = tmp->next;
            cur->next = tmp;
            cur = cur->next;
            // 如果弹出的元素不是其所在链表的最后一个
            // 将弹出元素的下一个元素入堆
            if(next){
                que.push(next);
            }
        }
        // 防止成环
        cur->next = NULL;

        return dummyhead->next;
    }
};
```



既然用到了优先级队列，那就记录一下**优先级队列如何自定义比较函数**：

1. **重载操作符**

```c++
bool operator < (const node &a, const node &b){
    return a.value < b.value;
}
priority_queue<node> q;
```

2. **自定义比较函数模板结构**

```c++
struct cmp{
    bool operator ()(const node& a, const node& b){
        return a.value > b.value;
    }
};
priority_queue<node, vector<node>, cmp> q;
```

```c++
static bool cmp(node& a, node& b){
    return a.value > b.value;
}
priority_queue<node, vector<node>, decltype(&cmp)> q(cmp);
```



### 7.14 LRU缓存

<img src="hot100记录.assets/image-20240325102346972.png" alt="image-20240325102346972" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325102357730.png" alt="image-20240325102357730" style="zoom:80%;" />

```c++
struct DLinkNode{
    int key;
    int value;
    DLinkNode* pre;
    DLinkNode* next;
    DLinkNode(): key(0), value(0), pre(NULL), next(NULL) {}
    DLinkNode(int _key, int _value): key(_key), value(_value), pre(NULL), next(NULL) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkNode*> cache;
    DLinkNode* head;
    DLinkNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        head = new DLinkNode();
        tail = new DLinkNode();
        head->next = tail;
        tail->pre = head;
    }
    
    int get(int key) {
        // key如果不存在，则返回-1
        if(!cache.count(key)){
            return -1;
        }
        // 如果key存在，先通过哈希表定位，再移动到头部
        DLinkNode* node = cache[key];
        move2head(node);
        return node->value;
    }
    
    void put(int key, int value) {
        // 如果key存在，则修改key的value并移动到头部
        if(cache.count(key)){
            DLinkNode* node = cache[key];
            move2head(node);
            node->value = value;
        }
        else{
            // 如果key不存在，则新建节点
            DLinkNode* newnode = new DLinkNode(key, value);
            // 加入哈希表
            cache.insert({key, newnode});
            // 加入链表
            add2head(newnode);
            size++;
            // 判断空间是否超过
            if(size > capacity){
                // 删除尾结点
                DLinkNode* removedtail = removetail();
                // 删除哈希表中对应值
                cache.erase(removedtail->key);
                // 防止内存泄漏
                delete removedtail;
                size--;
            }
        }
    }

    void remove(DLinkNode* node){
        node->next->pre = node->pre;
        node->pre->next = node->next;
    }

    void add2head(DLinkNode* node){
        node->next = head->next;
        node->pre = head;
        head->next = node;
        node->next->pre = node;
    }

    void move2head(DLinkNode* node){
        remove(node);
        add2head(node);
    }

    DLinkNode* removetail(){
        DLinkNode* removed = tail->pre;
        remove(removed);
        return removed;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



## 8 二叉树



### 8.0 前言

> 树的结构体定义

```c++
// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```



> 通过数组构造树

![image-20240325153510279](hot100记录.assets/image-20240325153510279.png)

```c++
// 将null定义成数据范围之外的数
const int null = 32767;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
 
TreeNode* nums2Tree(vector<int>& nums){
    if(nums.size() == 0) return NULL;

    queue<TreeNode*> que;
    TreeNode* root = new TreeNode(nums[0]);
    que.push(root);
    int idx = 0;
    while(!que.empty() && idx < nums.size()){
        TreeNode* cur = que.front();
        que.pop();

        idx++;
        if(idx >= nums.size()) break;
        if(nums[idx] != null){
            TreeNode* left = new TreeNode(nums[idx]);
            cur->left = left;
            que.push(left);
        }
        idx++;
        if(idx >= nums.size()) break;
        if(nums[idx] != null){
            TreeNode* right = new TreeNode(nums[idx]);
            cur->right = right;
            que.push(right);
        }
    }
    return root;
}
```





> 二叉树的递归遍历

```c++
// 前序遍历
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

```c++
// 中序遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

```c++
// 后序遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```



> 二叉树的迭代遍历

```c++
// 前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

```c++
// 中序遍历
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

```c++
// 后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```



### 8.1 二叉树的中序遍历

<img src="hot100记录.assets/image-20240325105409477.png" alt="image-20240325105409477" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        if(root == NULL) return result;
        
        TreeNode* cur = root;
        stack<TreeNode*> st;
        st.push(cur);
        cur = cur->left;
        while(cur || !st.empty()){
            if(cur){
                st.push(cur);
                cur = cur->left;
            }
            else{
                TreeNode* tmp = st.top();
                st.pop();
                result.push_back(tmp->val);
                cur = tmp->right;
            }
        }

        return result;
    }
};
```



### 8.2 二叉树的最大深度

<img src="hot100记录.assets/image-20240325110851429.png" alt="image-20240325110851429" style="zoom:80%;" />

递归获得根节点左右子树的深度，取最大值后+1返回。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // DFS
        if(root == NULL) return 0;

        int ldpth = 0, rdpth = 0;
        if(root->left) ldpth = maxDepth(root->left);
        if(root->right) rdpth = maxDepth(root->right);

        return max(ldpth, rdpth) + 1;
    }
};
```



### 8.3 翻转二叉树

<img src="hot100记录.assets/image-20240325111447077.png" alt="image-20240325111447077" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325111500305.png" alt="image-20240325111500305" style="zoom:80%;" />

遍历每个节点，交换每个节点的左右子节点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL || (root->left == NULL && root->right == NULL))
            return root;
        
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()){
            TreeNode* tmp = que.front();
            que.pop();

            if(tmp->left) que.push(tmp->left);
            if(tmp->right) que.push(tmp->right);
            swap(tmp->left, tmp->right);
        }
        return root;
    }
};
```



### 8.4 对称二叉树

<img src="hot100记录.assets/image-20240325112201232.png" alt="image-20240325112201232" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325112214772.png" alt="image-20240325112214772" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL || (root->left == NULL && root->right == NULL)){
            return true;
        }

        // 先将根节点的左右节点入队
        queue<TreeNode*> que;
        if(root->left && root->right && root->left->val == root->right->val){
            que.push(root->left);
            que.push(root->right);
        }
        else{
            return false;
        }

        while(!que.empty()){
            TreeNode* t1 = que.front();
            que.pop();
            TreeNode* t2 = que.front();
            que.pop();
            // 对应节点都存在，且val值相等才入队
            // 若对应节点都为NULL也是符合对称条件的
            // t1的左节点与t2的右节点入队
            if(t1->left && t2->right){
                if(t1->left->val == t2->right->val)
                    que.push(t1->left), que.push(t2->right);
                else    
                    return false;
            }
            else if(t1->left || t2->right){
                return false;
            }
            // t2的左节点与t1的右节点入队
            if(t1->right && t2->left){
                if(t1->right->val == t2->left->val)
                    que.push(t1->right), que.push(t2->left);
                else    
                    return false;
            }
            else if(t1->right || t2->left){
                return false;
            }
        }

        return true;
    }
};
```



### 8.5 二叉树的直径

<img src="hot100记录.assets/image-20240325120442720.png" alt="image-20240325120442720" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325120459352.png" alt="image-20240325120459352" style="zoom:80%;" />

二叉树任意两个节点之间的最长路径的长度肯定在两个叶子结点之间产生，所以是需要获得每个节点左右子树的最大深度即可算以该节点作为转折点的最长路径的长度。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;
    int depth(TreeNode* node){
        if(node == NULL) return 0;

        // 递归获得左右子树的最大深度
        int ldepth = depth(node->left);
        int rdepth = depth(node->right);
        // 以该节点为转折点的最长路径为ldepth + rdepth
        // 并更新res 
        res = max(res, ldepth + rdepth);
        return max(ldepth, rdepth) + 1;
    }
    
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return res;
    }
};
```



### 8.6 二叉树的层序遍历

<img src="hot100记录.assets/image-20240325121009431.png" alt="image-20240325121009431" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325121019705.png" alt="image-20240325121019705" style="zoom:80%;" />

用队列即可实现

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if(root == NULL) return result;
        
        que.push(root); 
        while(!que.empty()){
            int size = que.size();
            vector<int> record;
            while(size--){
                TreeNode* tmp = que.front();
                record.push_back(tmp->val);
                que.pop();
                if(tmp->left != NULL) que.push(tmp->left);
                if(tmp->right != NULL) que.push(tmp->right);
            }
            result.push_back(record);
        }
        return result;
    }
};
```



### 8.7 将有序数组转换为二叉搜索树

<img src="hot100记录.assets/image-20240325132256213.png" alt="image-20240325132256213" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325132311955.png" alt="image-20240325132311955" style="zoom:80%;" />

每次选择数组序列中的中间元素作为根节点

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildtree(vector<int> &nums, int l, int r){
        if(l > r) return NULL;
        int mid = (l + r) >> 1;
        TreeNode* newnode = new TreeNode(nums[mid]);
        newnode->left = buildtree(nums, l, mid - 1);
        newnode->right = buildtree(nums, mid + 1, r);
        return newnode;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildtree(nums, 0, nums.size() - 1);
    }
};
```



### 8.8 验证二叉搜索树

<img src="hot100记录.assets/image-20240325132834865.png" alt="image-20240325132834865" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325132846794.png" alt="image-20240325132846794" style="zoom:80%;" />

**二叉搜索树的性质：中序遍历是严格的升序序列**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        // 二叉搜索树的性质：中序遍历是严格的升序序列
        stack<TreeNode*> st;
        TreeNode* cur = root, *pre = NULL;
        while(cur || !st.empty()){
            if(cur){
                st.push(cur);
                cur = cur->left;
            }
            else{
                cur = st.top();
                st.pop();
                if(pre && pre->val >= cur->val){
                    return false;
                }
                pre = cur;
                cur = cur->right;
            }
        }
        return true;
    }
};
```



### 8.9 二叉搜索树中第K小的元素

<img src="hot100记录.assets/image-20240325133345399.png" alt="image-20240325133345399" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325133408749.png" alt="image-20240325133408749" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        // cnt记录遍历的是第几个数
        int cnt = 0;
        while(cur || !st.empty()){
            if(cur){
                st.push(cur);
                cur = cur->left;
            }
            else{
                cur = st.top();
                cnt++;
                if(cnt == k){
                    return cur->val;
                }
                st.pop();
                cur = cur->right;
            }
        }

        return 0;
    }
};
```

> 和二叉搜索树相关的题目基本都是在中序遍历的模板之上做对应的功能增加。



### 8.10 二叉树的右视图

<img src="hot100记录.assets/image-20240325133559966.png" alt="image-20240325133559966" style="zoom:80%;" />

> 层序遍历

通过层序遍历，记录每一层最右边的元素。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return res;
        
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()){
            int nums = que.size();
            for(int i = 0; i < nums; i++){
                TreeNode* tmp = que.front();
                que.pop();
                if(tmp->left) que.push(tmp->left);
                if(tmp->right) que.push(tmp->right);
                if(i == nums - 1){
                    res.push_back(tmp->val);
                }
            }
        }

        return res;
    }
};
```



> 前序遍历的变体

前序遍历是 根-->左-->右，对这道题进行变体，变成  根-->右-->左，同时记录遍历节点的深度，第一次到达该深度所遍历的节点就是该深度最右边的节点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return res;

        // st记录节点，depth记录深度
        // 其实也可以开这样的堆栈 stack<pair<TreeNode*, int>> st;
        stack<TreeNode*> st;
        stack<int> depth;
        unordered_set<int> set;
        st.push(root);
        depth.push(0);

        // 前序遍历模板的变体
        while(!st.empty()){
            TreeNode* node = st.top();
            int curDepth = depth.top();
            st.pop(), depth.pop();
            
            // 判断是否遍历过当前深度
            // 如果没有遍历过，记录node->val
            if(set.find(curDepth) == set.end()){
                set.insert(curDepth);
                res.push_back(node->val);
            }

            if(node->left){
                st.push(node->left);
                depth.push(curDepth + 1);
            }
            if(node->right){
                st.push(node->right);
                depth.push(curDepth + 1);
            }
        }
        return res;
    }
};
```



### 8.11 二叉树展开为链表

<img src="hot100记录.assets/image-20240325135558981.png" alt="image-20240325135558981" style="zoom:80%;" />

这题关键是对相应操作的模拟。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* cur = root;
        while(cur){
            TreeNode* left = cur->left;
            TreeNode* right = cur->right;
            // 左节点赋值为空别忘记了
            cur->left = NULL;
            if(left){
                // 如果存在左子树，就将左子树移动到原来右子树的位置
                cur->right = left;
                // 如果原右子树存在，移动到原左子树最右边的节点的右子节点
                if(right){
                    TreeNode* tmp = left;
                    while(tmp->right){
                        tmp = tmp->right;
                    }
                    tmp->right = right;
                }
            }
            cur = cur->right;
        }
    }
};
```



### 8.12 从前序与中序遍历序列构造二叉树

<img src="hot100记录.assets/image-20240325135907991.png" alt="image-20240325135907991" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325135919390.png" alt="image-20240325135919390" style="zoom:80%;" />

通过`preorder`的第一个元素确定根节点的值，再在`inorder`中确定左右子树序列

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 1){
            TreeNode* node = new TreeNode(preorder[0]);
            return node;
        }

        // preorder[0]为根节点
        TreeNode* node = new TreeNode(preorder[0]);
        // 在inorder中找preorder[0]的位置
        int val = preorder[0];
        int idx;
        for(int i = 0; i < preorder.size(); i++){
            if(val == inorder[i]){
                idx = i;
                break;
            }
        }
        // l, r分别是左右子树元素的数量
        int l = idx - 0, r = preorder.size() - idx - 1;
        // 递归构造相应的子树
        if(l){
            // vector相互赋值时区间是 左闭右开
            vector<int> lp(preorder.begin() + 1, preorder.begin() + l + 1);
            vector<int> li(inorder.begin(), inorder.begin() + l);
            node->left = buildTree(lp, li);
        }
        if(r){
            vector<int> rp(preorder.begin() + l + 1, preorder.end());
            vector<int> ri(inorder.begin() + idx + 1, inorder.end());
            node->right = buildTree(rp, ri);
        }
        return node;
    }
};
```

这题还可以写一个递归时只传左右子树开始和终止下标的版本：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:    
    TreeNode* buildMyTree(vector<int>& preorder, int pst, int ped, vector<int>& inorder, int ist, int ied){
        if(pst == ped){
            TreeNode* node = new TreeNode(preorder[pst]);
            return node;            
        }

        TreeNode* node = new TreeNode(preorder[pst]);
        int val = preorder[pst];
        int idx;
        for(int i = ist; i <= ied; i++){
            if(val == inorder[i]){
                idx = i;
                break;
            }
        }
        int l = idx - ist, r = ied - idx;
        if(l){
            node->left = buildMyTree(preorder, pst + 1, pst + l, inorder, ist, ist + l - 1);
        }
        if(r){
            node->right = buildMyTree(preorder, pst + l + 1, ped, inorder, idx + 1, ied);
        }
        return node;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildMyTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }
};
```



### 8.13 路径总和III

<img src="hot100记录.assets/image-20240325145443101.png" alt="image-20240325145443101" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325145452762.png" alt="image-20240325145452762" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 前缀和：从根节点到当前节点路径上所有点的和
    unordered_map<long long, int> map;
    int count = 0;
    long long sum = 0;
    void inorder(TreeNode* node, int targetSum){
        if(node == NULL) return;

        sum += node->val;
        if(map.find((long long) sum - targetSum) != map.end()){
            count += map[(long long) sum - targetSum];
        }
        // find之后再增加当前节点的前缀和
        // 防止targetSum为0时，将自己加为一种情况的现象
        map[sum] ++;

        if(node->left) inorder(node->left, targetSum);
        if(node->right) inorder(node->right, targetSum);
        
        // 存在回溯的思想
        // 使得只与该路径之前点的前缀和进行计算
        map[sum]--;
        sum -= node->val;
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        // 需要增加一个{0, 1}，这样可以统计包括根节点在内的路径和
        map.insert({0, 1});
        inorder(root, targetSum);
        return count;
    }
};
```



### 8.14 二叉树的最近公共祖先

<img src="hot100记录.assets/image-20240325150129347.png" alt="image-20240325150129347" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325150142247.png" alt="image-20240325150142247" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* ans;
    bool backorder(TreeNode* root, TreeNode* p, TreeNode* q){
        if(root == NULL) return false;

        bool l = backorder(root->left, p, q), r = backorder(root->right, p, q);
        // root是目标节点的两种情况：
        // 1. p，q分别在root的左右子树上
        // 2. root为p或q中的一个，且root的左子树或者右子树上存在p或q
        if((l && r) || ((root == p || root == q) && (l || r))){
            ans = root;
        }

        return root == p || root == q || l || r;
    }
    
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        backorder(root, p, q);
        return ans;
    }
};
```



### 8.15 二叉树中的最大路径和

<img src="hot100记录.assets/image-20240325150426027.png" alt="image-20240325150426027" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240325150437816.png" alt="image-20240325150437816" style="zoom:80%;" />

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = INT_MIN;
    int backorder(TreeNode* root){
        if(root == NULL) return 0;

        // 计算左右子树上最大的路径和，如果小于0就置为0
        int l = max(backorder(root->left), 0), r = max(backorder(root->right), 0);
        // 计算以当前节点作为转折点的最大路径值
        int cur_sum = root->val + l + r;
        // 更新结果
        ans = max(ans, cur_sum);

        // 返回以该节点为起点的最长路径值（该路径一直往下，不存在转折）
        return root->val + max(l, r);
    }
    
    int maxPathSum(TreeNode* root) {
        backorder(root);
        return ans;
    }
};
```



## 9 图论



### 9.1 岛屿数量

<img src="hot100记录.assets/image-20240326091259950.png" alt="image-20240326091259950" style="zoom:80%;" />

> DFS（回溯）

```c++
class Solution {
private:
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        if (visited[x][y] || grid[x][y] == '0') return; // 终止条件：访问过的节点 或者 遇到海水
        
        visited[x][y] = true; // 标记访问过
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            dfs(grid, visited, nextx, nexty);
        }
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++; // 遇到没访问过的陆地，+1
                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```



> BFS（队列）

```c++
class Solution {
private:
    int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
    void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        visited[x][y] = true;

        while(!que.empty()){
            auto cur = que.front();
            que.pop();
            for(int i = 0; i < 4; i++){
                int nextx = cur.first + dx[i], nexty = cur.second + dy[i];
                if(nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
                // 若下一个坐标为陆地且未被访问，则访问
                if(!visited[nextx][nexty] && grid[nextx][nexty] == '1'){
                    visited[nextx][nexty] = true;
                    que.push({nextx, nexty});
                }
            }
        }
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++; // 遇到没访问过的陆地，+1
                    bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```



### 9.2 腐烂的橘子

<img src="hot100记录.assets/image-20240326092438847.png" alt="image-20240326092438847" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326092450840.png" alt="image-20240326092450840" style="zoom:80%;" />

BFS，先遍历一边所有格子，将所有坏橘子入队

每出队一个元素，就将其可以感染的橘子入队

```c++
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int, int>> que;
        int m = grid.size(), n = grid[0].size();
        int num_good = 0;
        // 找所有烂橘子
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 2)
                    que.push({i, j});
                else if(grid[i][j] == 1)
                    num_good++;
            }
        }

        // 对没有橘子的情况做一下特判
        if(que.empty() && num_good == 0){
            return 0;
        }

        // 进行感染
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
        int ans = -1;
        while(!que.empty()){
            ans++;
            int size = que.size();
            for(int i = 0; i < size; i++){
                int x = que.front().first, y = que.front().second;
                que.pop();
                // 查看四个方向是否存在新鲜橘子可以感染
                for(int j = 0; j < 4; j++){
                    int nextx = x + dx[j], nexty = y + dy[j];
                    if(nextx < 0 || nextx >= m || nexty < 0 || nexty >= n)
                        continue;
                    if(grid[nextx][nexty] == 1){
                        grid[nextx][nexty] = 2;
                        que.push({nextx, nexty});
                    }
                }
            }
        }
        // 检查是否还有好橘子
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    ans = -1;
                    break;
                }
            }
            if(ans == -1) break;
        } 

        return ans;      
    }
};
```



### 9.3 课程表

<img src="hot100记录.assets/image-20240326094113355.png" alt="image-20240326094113355" style="zoom:80%;" />

这道题主要考察的是**拓扑排序**

> 什么是拓扑排序

在图论中，**拓扑排序（Topological Sorting）**是一个**有向无环图（DAG，Directed Acyclic Graph）**的所有顶点的线性序列，且该序列必须满足以下条件：

1. 每个顶点出现且只出现一次
2. 若存在一条从顶点A到顶点B的路径，那么在序列中顶点A一定出现的顶点B前面

而题目中，只有课程之间组成的是有向无环图，才能保证学习完所有课程，若有环，则会有课程互为前置条件，导致无法完成学习。

> 如何写出DAG的拓扑排序

1. 从DAG中选择一个入度为0的顶点，并输出
2. 从图中删除该顶点以及所有以它为起点的有向边
3. 重复1,2，直到当前DAG图为空。

若经过上述操作，图不为空，则说明存在环。

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 拓扑排序，看有向图是否成环
        
        // 统计节点的入度
        vector<int> d(numCourses, 0);
        // 存储图
        vector<vector<int>> map(numCourses);
        for(int i = 0; i < prerequisites.size(); i++){
            // b --> a
            int a = prerequisites[i][0], b = prerequisites[i][1];
            d[a]++;
            map[b].push_back(a);
        }

        // 统计可以完成学习的课程数量
        int res = 0;
        queue<int> que;
        // 先统计所有入度为0的节点
        for(int i = 0; i < numCourses; i++){
            if(d[i] == 0){
                res ++;
                que.push(i);
            }
        }
        while(!que.empty()){
            int cur = que.front();
            que.pop();
            for(int i = 0; i < map[cur].size(); i++){
                // 对应节点入度 -1
                d[map[cur][i]]--;
                // 若当前节点入度为0，则入队
                if(d[map[cur][i]] == 0){
                    res ++;
                    que.push(map[cur][i]);
                }
            }
        }

        if(res == numCourses)
            return true;
        else
            return false;
    }
};
```



### 9.4 实现Tire树（前缀树）

<img src="hot100记录.assets/image-20240326095255445.png" alt="image-20240326095255445" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326095307473.png" alt="image-20240326095307473" style="zoom:80%;" />

> 什么是Trie树

Trie树，又叫字典树、前缀树（Prefix Tree），是一种多叉树的结构。

<img src="hot100记录.assets/image-20240326095707428.png" alt="image-20240326095707428" style="zoom:80%;" />

上图是一棵Trie树，表示了关键字集合`{"a", "to", "tea", "ted", "ten", "i", "in", "inn"}`。从上图中可以归纳出Trie树的基本性质：

1. 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。
2. 从根节点到**某一个节点**，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符互不相同。

通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。

可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做**前缀树（Prefix Tree）**。

```c++
class Trie {
public:
    typedef struct NODE{
        // 统计以当前节点的字符结尾的字符串的个数
        // 相当于又加了词频统计的功能
        int sum;
        // 指向下一个字符的指针 0~26对应'a'~'z'
        struct NODE* next[26];
    }MyNODE;

    // 需要一个根节点
    MyNODE* root;
    
    Trie() {
        root = new MyNODE();
    }
    
    void insert(string word) {
        MyNODE* cur = root;
        // 遍历每一个字符
        for(int i = 0; i < word.size(); i++){
            // 如果不存在当前的前缀，则新建节点
            if(!cur->next[word[i] - 'a']){
                MyNODE* newnode = new MyNODE();
                cur->next[word[i] - 'a'] = newnode;
            }
            // 指向下一个前缀的地址
            cur = cur->next[word[i] - 'a'];
        }
        // 当前字符串的数量+1
        cur->sum++;
    }
    
    bool search(string word) {
        MyNODE* cur = root;
        // 遍历每一个字符
        for(int i = 0; i < word.size(); i++){
            // 如果不存在当前的前缀，则返回false
            if(!cur->next[word[i] - 'a']){
                return false;
            }
            // 指向下一个前缀的地址
            cur = cur->next[word[i] - 'a'];
        }

        // 判断该字符串是否存在
        // 这里跟判断前缀是否存在不同，假设只有一个字符串"apple"
        // 我们可以说存在前缀"app"，但不能说存在字符串"app"
        if(cur->sum) return true;
        else return false;
    }
    
    bool startsWith(string prefix) {
        MyNODE* cur = root;
        // 除了最后的特判，其他和判断字符串是否存在相同
        for(int i = 0; i < prefix.size(); i++){
            if(!cur->next[prefix[i] - 'a']){
                return false;
            }
            cur = cur->next[prefix[i] - 'a'];
        }
        
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```



## 10 回溯

回溯的三大步骤：

1. 为进入下一层的回溯做相应准备
2. 回溯
3. 恢复现场



### 10.1 全排列

<img src="hot100记录.assets/image-20240326102805335.png" alt="image-20240326102805335" style="zoom:80%;" />

典型回溯，同时需要开辟一个数组`used`用于记录对应的元素在前面的序列中是否已经出现

```c++
class Solution {
public:
    int len;
    vector<vector<int>> res;
    vector<int> path;
    void backtracing(vector<int>& nums, vector<bool>& used){
        if(path.size() == len){
            res.push_back(path);
            return;
        }

        for(int i = 0; i < len; i++){
            if(!used[i]){
                used[i] = true;
                path.push_back(nums[i]);
                // 回溯
                backtracing(nums, used);
                // 恢复现场
                used[i] = false;
                path.pop_back();
            }
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        len = nums.size();
        vector<bool> used(len, false);
        backtracing(nums, used);
        return res;
    }
};
```



### 10.2 子集

<img src="hot100记录.assets/image-20240326103102115.png" alt="image-20240326103102115" style="zoom:80%;" />

组合问题，相同元素的不同排列属于一种情况，所以需要按顺序遍历。且需要记录不同长度，不像前一题`path`的长度为`nums`的长度时才进入结果集。

```c++
class Solution {
public:
    int len;
    vector<vector<int>> res;
    vector<int> path;
    // idx表示接下来需要从哪一个数开始考虑
    void backtracing(vector<int>& nums, int idx){
        res.push_back(path);
        if(idx == len) return;

        for(int i = idx; i < len; i++){
            path.push_back(nums[i]);
            backtracing(nums, i + 1);
            path.pop_back();
        }
    }
    
    vector<vector<int>> subsets(vector<int>& nums) {
        len = nums.size();
        backtracing(nums, 0);
        return res;
    }
};
```



### 10.3 电话号码的字母组合

<img src="hot100记录.assets/image-20240326103431141.png" alt="image-20240326103431141" style="zoom:80%;" />

这题除了需要建立一个`string`数组进行号码数字与字符的映射之外，跟前面的题目处理过程类似。

```c++
class Solution {
public:
    // 建立号码数字与字符的映射关系
    string map[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };  
    
    int len;
    vector<string> res;
    string path;
    // idx记录此次回溯考虑的是号码中的第几个数字
    void backtracing(string& digits, int idx){
        if(idx == len){
            res.push_back(path);
            return;
        }

        int digit = digits[idx] - '0';
        for(int i = 0; i < map[digit].size(); i++){
            path.push_back(map[digit][i]);
            backtracing(digits, idx + 1);
            path.pop_back();
        }
    }
    
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0)  return res;
        
        len = (int) digits.size();
        backtracing(digits, 0);
        return res;
    }
};
```



### 10.4 组合总和

<img src="hot100记录.assets/image-20240326103804493.png" alt="image-20240326103804493" style="zoom:80%;" />

利用变量`restsum`记录完成该路径剩余所需的和

+ `restsum == 0` 则路径终止，且该路径符合条件
+ `restsum < 0` 则路径终止，但该路径不符合条件，不进入结果集

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int len;
    void backtracing(vector<int>& candidates, int idx, int restsum){
        if(restsum == 0){
            res.push_back(path);
            return;
        }
        else if(restsum < 0)
            return;

        for(int i = idx; i < len; i++){
            path.push_back(candidates[i]);
            // 注意这题元素可以重复使用，所以进下一层回溯时，idx与这一层相同
            backtracing(candidates, i, restsum - candidates[i]);
            path.pop_back();
        }
    }
    
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        len = candidates.size();
        backtracing(candidates, 0, target);
        return res;
    }
};
```



### 10.5 括号生成

<img src="hot100记录.assets/image-20240326104140801.png" alt="image-20240326104140801" style="zoom:80%;" />

```c++
class Solution {
public:
    vector<string> res;
    string path;
    void backtracing(int idxl, int idxr, int& n){
        // 左右括号的序号从0开始
        // idxl 表示当前需要考虑第idxl个'('
        // idxr 表示当前需要考虑第idxr个')'
        // 如果两者都需要考虑第n个时，表示已经结束，保存当前path并返回
        if(idxl == n && idxr == n){
            res.push_back(path);
            return;
        }

        // idxl 只要保证小于n就可以继续放
        if(idxl < n){
            path.push_back('(');
            backtracing(idxl + 1, idxr, n);
            path.pop_back();
        }
        // idxr 需要保证小于idxl才能继续放
        if(idxr < idxl){
            path.push_back(')');
            backtracing(idxl, idxr + 1, n);
            path.pop_back();
        }
    }
    
    vector<string> generateParenthesis(int n) {
        backtracing(0, 0, n);
        return res;
    }
};
```



### 10.6 单词搜索

<img src="hot100记录.assets/image-20240326104442574.png" alt="image-20240326104442574" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326104501518.png" alt="image-20240326104501518" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326104512741.png" alt="image-20240326104512741" style="zoom:80%;" />

直接DFS，结束。

因为这题找到一个结果就可以了，所以定义一个全局的`flag`，找到一个结果直接结束。

```c++
class Solution {
public:
    int m, n, len;
    bool flag;
    int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
    void dfs(vector<vector<char>>& board, string& word, vector<vector<bool>>& visited, int idx, int x, int y){
        if(idx == len - 1 && board[x][y] == word[idx]){
            flag = true;
            return;
        }
        if(board[x][y] != word[idx]) return;

        for(int i = 0; i < 4; i++){
            int nextx = x + dx[i], nexty = y + dy[i];
            if(nextx < 0 || nextx >= m || nexty < 0 || nexty >= n || visited[nextx][nexty])
                continue;
            visited[nextx][nexty] = true;
            dfs(board, word, visited, idx + 1, nextx, nexty);
            visited[nextx][nexty] = false;
        }
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size(), n = board[0].size(), len = word.size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        for(int i = 0; i < m; i++){
            if(flag) break;
            for(int j = 0; j < n; j++){
                if(flag) break;
                visited[i][j] = true;
                dfs(board, word, visited, 0, i, j);
                visited[i][j] = false;
            }
        }
        return flag;
    }
};
```

上面是在回溯里面判断是否符合条件的版本，下面的是进入回溯之前先判断是否符合条件：

```c++
class Solution {
public:
    int m, n, len;
    bool flag;
    int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
    void dfs(vector<vector<char>>& board, string& word, vector<vector<bool>>& visited, int idx, int x, int y){
        if(idx == len){
            flag = true;
            return;
        }

        for(int i = 0; i < 4; i++){
            int nextx = x + dx[i], nexty = y + dy[i];
            if(nextx < 0 || nextx >= m || nexty < 0 || nexty >= n || visited[nextx][nexty])
                continue;
            if(board[nextx][nexty] == word[idx] && visited[nextx][nexty] == false){
                visited[nextx][nexty] = true;
                dfs(board, word, visited, idx + 1, nextx, nexty);
                visited[nextx][nexty] = false;
            }
        }
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size(), n = board[0].size(), len = word.size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        for(int i = 0; i < m; i++){
            if(flag) break;
            for(int j = 0; j < n; j++){
                if(flag) break;
                if(board[i][j] == word[0]){
                    visited[i][j] = true;
                    dfs(board, word, visited, 1, i, j);
                    visited[i][j] = false;
                }
            }
        }
        return flag;
    }
};
```



### 10.7 分割回文串

<img src="hot100记录.assets/image-20240326105215081.png" alt="image-20240326105215081" style="zoom:80%;" />

> 朴素回溯

每次获得一个区间时，都调用`check()`函数，看该区间的字符串是否是回文子串

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;

    bool check(string& s, int st, int ed){
        while(st < ed){
            if(s[st] != s[ed]) return false;
            st ++, ed --;
        }
        return true;
    }

    void bakctracing(string& s, int st){
        if(st == s.size()){
            res.push_back(path);
            return;
        }

        for(int i = st; i < s.size(); i++){
            if(check(s, st, i)){
                path.push_back(s.substr(st, i - st + 1));
                bakctracing(s, i + 1);
                path.pop_back();
            }
        }
    }
    
    vector<vector<string>> partition(string s) {
        bakctracing(s, 0);
        return res;
    }
};
```

> 动态规划优化的回溯

利用动态规划记录每个区间是否是回文子串，**空间换时间**

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;

    void bakctracing(string& s, int st, vector<vector<bool>>& dp){
        if(st == s.size()){
            res.push_back(path);
            return;
        }

        for(int i = st; i < s.size(); i++){
            if(dp[st][i]){
                path.push_back(s.substr(st, i - st + 1));
                bakctracing(s, i + 1, dp);
                path.pop_back();
            }
        }
    }
    
    vector<vector<string>> partition(string s) {
        int n = s.size();
        // dp[i][j]数组 存s[i]~s[j]是否为回文串
        // 相当于用空间换时间，之前的算法是每遍历一个子串就需要判断一下是否是回文串
        vector<vector<bool>> dp(n, vector<bool>(n, true));
        // 这里i的遍历需要从后往前，否则会出错
        // 从后往前遍历其实保证了i~j之间的子串在之前都已经经过判断
        for(int i = n - 1; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j];
            }
        }

        bakctracing(s, 0, dp);
        return res;
    }
};
```



### 10.8 N皇后

<img src="hot100记录.assets/image-20240326110511759.png" alt="image-20240326110511759" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326110521423.png" alt="image-20240326110521423" style="zoom:80%;" />

需要四个数组分别记录`行`、`列`、`对角线`、`反对角线`是否可以放置皇后，但由于是按行遍历的，所以不需要考虑`行`，开辟三个数组记录即可。

+ `col[i]`：第`i`列是否可以放置皇后
+ `diag[i]`：第`i`条对角线是否可以放置皇后
+ `idiag[i]`：第`i`条反对角线是否可以放置皇后

主要问题还是**该点属于第几条（反）对角线**，画一下图就能推出来了。

坐标为`[x, y]`的点属于

+ `diag[x + y]`
+ `idiag[y - x + n - 1]`

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> map;
    void backtracing(int idx, int& n, vector<bool>& col, vector<bool>& diag, vector<bool>& idiag){
        // idx表示当前考虑第idx行的皇后
        if(idx == n){
            res.push_back(map);
            return;
        }

        for(int i = 0; i < n; i++){
            if(col[i] == false && diag[idx + i] == false && idiag[i - idx + n - 1] == false){
                map[idx][i] = 'Q';
                col[i] = true, diag[idx + i] = true, idiag[i - idx + n - 1] = true;
                backtracing(idx + 1, n, col, diag, idiag);
                map[idx][i] = '.';
                col[i] = false, diag[idx + i] = false, idiag[i - idx + n - 1] = false;
            }
        }
    }
    
    vector<vector<string>> solveNQueens(int n) {
        vector<bool> col(n, false), diag(2 * n - 1, false), idiag(2 * n - 1, false);
        // 初始化棋盘
        for(int i = 0; i < n; i++){
            string tmp = "";
            for(int j = 0; j < n; j++)
                tmp += '.';
            map.push_back(tmp);
        }

        backtracing(0, n, col, diag, idiag);

        return res;
    }
};
```



## 11 二分查找



### 11.1 搜索插入位置

<img src="hot100记录.assets/image-20240326111506576.png" alt="image-20240326111506576" style="zoom:80%;" />

```c++
class Solution {
public:
    int bisearch(vector<int> nums, int target){
        nums.insert(nums.begin(), -1e4 - 10);
        int l = 0, r = nums.size() - 1;
        int mid;
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1;
        }

        if(nums[l] == target) return l - 1;
        else return l;
    }
    
    int searchInsert(vector<int>& nums, int target) {
        return bisearch(nums, target);
    }
};
```



### 11.2 搜索二维矩阵

<img src="hot100记录.assets/image-20240326112016097.png" alt="image-20240326112016097" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326112028830.png" alt="image-20240326112028830" style="zoom:80%;" />

> 从右上角开始搜索

感觉用6.4 搜索二维矩阵II的思路：从右上角开始搜索也可以吧

+ 当前值 ` < target`，向下搜索
+ 当前值 ` > target`，向左搜索



> 两次二分查找

+ 第一次二分查找：确定`target`所在的行
+ 第二次二分查找：确定`target`所在的列

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        
        // find the right row
        // 利用最后一列的数值定位
        int l = 0, r = m - 1;
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(matrix[mid][n - 1] <= target) l = mid;
            else r = mid - 1;
        }
        // 一些特判
        // 如果刚好相等，则直接返回，不用再在该行进行遍历
        if(matrix[l][n - 1] == target) return true;
        // 如果target大于最大的数，则肯定不存在，返回false
        if(l == m - 1 && matrix[l][n - 1] < target) return false;
        // 上述二分查找找的是大于等于target的第一个数
        // 如果target >= matrix[l][n - 1]，则需要到下一行遍历
        int row = l;
        if(matrix[l][n - 1] < target) row ++;

        // find the right colume
        l = 0, r = n - 1;
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(matrix[row][mid] <= target) l = mid;
            else r = mid - 1;
        }

        if(matrix[row][l] == target) return true;
        else return false;
    }
};
```



> 一次二分查找（力扣官方题解）

将二维数组每行之间收尾相连，组成一个一维数组。进行一维数组的二分查找：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```



### 11.3 在排序数组中查找元素的第一个和最后一个的位置

<img src="hot100记录.assets/image-20240326133248415.png" alt="image-20240326133248415" style="zoom:80%;" />

关键主要是

+ `mid`计算的时候是否需要`+1`
+ 二分的`check`函数怎么写



```c++
class Solution {
public:
    // 考察两种二分查找的模板
    // 查找target第一次出现的位置
    int BiFindMin(vector<int>& nums, int target){
        int l = 0, r = nums.size() - 1;
        while(l < r){
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1; 
        }
        if(nums[l] == target) return l;
        else return -1;
    }

    // 查找target最后一次出现的位置
    int BiFindMax(vector<int>& nums, int target){
        int l = 0, r = nums.size() - 1;
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1; 
        }
        if(nums[l] == target) return l;
        else return -1;
    }
    
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};
        
        vector<int> res;
        res.push_back(BiFindMin(nums, target));
        res.push_back(BiFindMax(nums, target));

        return res;
    }
};
```



### 11.4 搜索旋转排序数组

<img src="hot100记录.assets/image-20240326133610813.png" alt="image-20240326133610813" style="zoom:80%;" />

```c++
class Solution {
public:
    int bifind(vector<int>& nums, int& target, int l, int r){
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        if(nums[l] == target) return l;
        else return -1;
    }

    int search(vector<int>& nums, int target) {
        // 通过二分法确定发生旋转的位置
        int l = 0, r = nums.size() - 1;
        // nums[l] > nums[r]说明l~r之间存在旋转点
        while(l < r && nums[l] > nums[r]){
            int mid = (l + r) >> 1;
            if(nums[mid] > nums[r]) l = mid + 1;
            else r = mid;
        }

        // 根据不同情况在对应分段中进行二分查找
        // l > 0：存在旋转
        if(l > 0){
            // 判断target应该在旋转点左边还是右边
            if(target > nums[nums.size() - 1])
                return bifind(nums, target, 0, l - 1);
            else
                return bifind(nums, target, l, nums.size() - 1);
        }
        // 不存在旋转
        else return bifind(nums, target, 0, nums.size() - 1);
    }
};
```



### 11.5 寻找旋转排序数组中的最小值

<img src="hot100记录.assets/image-20240326133850313.png" alt="image-20240326133850313" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240326133858830.png" alt="image-20240326133858830" style="zoom:80%;" />

这题思路应该和上一题一样

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while(nums[l] > nums[r]){
            int mid = (l + r) >> 1;
            if(nums[mid] > nums[r]) l = mid + 1;
            else r = mid;
        }
        return nums[l];
    }
};
```

但是有一个坑是在写这题的时候才发现的，**就是如果`check()`函数写成`nums[mid] > nums[l]`会报错**：

在样例`[2, 1]`下，会输出`2`

其实针对两个数的情况，此时`l == r - 1`，`mid = (l + r) >> 1 = (2 * r - 1) >> 1 = r - 1 = l`，此时若比较`nums[mid]`与`nums[l]`将必定是两个相等的数比较，比较没有意义。

> 为什么需要跟右边比较

Leetcode题解中用户armeria给出了下面的解释：

用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。

左、中、右三个位置的值相比较，有以下几种情况：

1. 左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界

```
		右
	中
左
```

2. 左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界

```
左
		右
	中
```

3. 左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界

```
     中
左
			右
```

4. 左值 > 中值, 中值 > 右值 ：单调递减，不可能出现

```
左
	中
		右
```

分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。

如果中值 < 右值，则最小值在左半边，可以收缩右边界。
如果中值 > 右值，则最小值在右半边，可以收缩左边界。
通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。

而情况1与情况3都是左值 < 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。

所以我们需要通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。



### 11.6 寻找两个正序数组的中位数

<img src="hot100记录.assets/image-20240326140234198.png" alt="image-20240326140234198" style="zoom:80%;" />

> 朴素法

先确定中位数的位置，再在`nums1`和`nums2`上分别设置两个指针`p1`和`p2`，向后移动对应的位置数量

但是这个方法的时间复杂度是 $O(m + n)$，虽然可以oc，但其实是不符合题目要求的

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), n2 = nums2.size();
        // flag用于指示第k个数应该是p1还是p2所指向的数
        int p1 = -1, p2 = -1, flag = 0;
        int cnt = (n1 + n2) / 2 + 1;
        int ans1, ans2;
        
        while(cnt--){
            if(p1 + 1 < n1 && p2 + 1 < n2){
                if(nums1[p1 + 1] < nums2[p2 + 1]) p1++, flag = 1;
                else p2++, flag = 2;
            }
            else if(p1 + 1 < n1) p1++, flag = 1;
            else if(p2 + 1 < n2) p2++, flag = 2;
            if(cnt == 1) ans1 = flag == 1 ? nums1[p1] : nums2[p2];
            if(cnt == 0) ans2 = flag == 1 ? nums1[p1] : nums2[p2];
        }

        if((n1 + n2) % 2){
            return ans2;
        }
        else{
            return (ans1 + ans2) / 2.0;
        }
    }
};
```



> 优化方法（力扣官方题解）

主要是在朴素法的基础上减少遍历次数

假设我们需要找第`k`小个数，那么可以比较`nums1`和`nums2`的第`[k/2]`个数：

+ 若`nums1[k/2] < nums2[k/2]`，那么说明`nums1`中的`[0, k/2]`范围内的数都不会是第`k`小的数
+ 反之亦然

这样一次就可以排除`[k/2]`个数。

```c++
class Solution {
public:
    double getKthNum(vector<int>& nums1, int st1, int ed1, vector<int>& nums2, int st2, int ed2, int k){
        int len1 = ed1 - st1 + 1, len2 = ed2 - st2 + 1;
        // 这样交换是为了保证nums1的长度小于等于nums2，减少后续的特判过程
        if(len1 > len2) return getKthNum(nums2, st2, ed2, nums1, st1, ed1, k);

        // len1 == 0，说明只能在nums2中找
        if(len1 == 0) return nums2[st2 + k - 1];
        // k == 1，即找最小的数，也可以直接返回
        if(k == 1) return min(nums1[st1], nums2[st2]);
        
        // 确定 k/2 个元素的位置，若超过数组长度就选最后一个
        int cur1 = st1 + min(len1, k / 2) - 1;
        int cur2 = st2 + min(len2, k / 2) - 1;

        if(nums1[cur1] < nums2[cur2]){
            // 排除了 cur1 - st1 + 1 个数，else之后同理
            return getKthNum(nums1, cur1 + 1, ed1, nums2, st2, ed2, k - (cur1 - st1 + 1));
        } 
        else{
            return getKthNum(nums1, st1, ed1, nums2, cur2 + 1, ed2, k - (cur2 - st2 + 1));
        }
    }
    
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), n2 = nums2.size();
        //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k
        int left = (n1 + n2 + 1) / 2;
        int right = (n1 + n2 + 2) / 2;
        
        return (getKthNum(nums1, 0, nums1.size() - 1, nums2, 0, nums2.size() - 1, left) + getKthNum(nums1, 0, nums1.size() - 1, nums2, 0, nums2.size() - 1, right)) / 2.0;
    }
};
```



## 12 栈



### 12.1 有效的括号

<img src="hot100记录.assets/image-20240327133056613.png" alt="image-20240327133056613" style="zoom:80%;" />

+ 遇到左括号，将与之对应的右括号入栈
+ 遇到右括号，与栈顶元素进行比较，看是否相同
  + 相同，则栈顶元素出栈
  + 不相同，则返回`fasle`

```c++
class Solution {
public:
    bool isValid(string s) {
        // 在题目条件下的剪枝
        if(s.size() % 2 != 0) return false;

        stack<int> st;
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '(' || s[i] == '[' || s[i] == '{'){
                switch(s[i]){
                    case '(':   st.push(')');
                                continue;
                    case '[':   st.push(']');
                                continue;
                    case '{':   st.push('}');
                                continue;
                }
            }else{
                if(st.empty() || st.top() != s[i]){
                    return false;
                }else{
                    st.pop();
                }
            }
        }
        // 若所有括号都是匹配的，遍历一遍之后，st将为空
        if(st.empty()){
            return true;
        }else{
            return false;
        }
    }
};
```



### 12.2 最小栈

<img src="hot100记录.assets/image-20240327133338750.png" alt="image-20240327133338750" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240327133348193.png" alt="image-20240327133348193" style="zoom:80%;" />

另外开辟一个栈`min`用于记录与`rec`中元素对应的栈中的最小值

```c++
class MinStack {
public:
    stack<int> rec;
    // 记录rec对应元素以下的最小值
    stack<int> min;

    MinStack() {

    }
    
    void push(int val) {
        rec.push(val);
        // 如果min栈为空，则当前val是最小值
        if(min.empty()){
            min.push(val);
        }
        else{
            // min栈栈顶元素表示加入val前栈中的最小值
            int cur_min = min.top();
            // 将val和min.top()更小的入栈
            if(val < cur_min) min.push(val);
            else min.push(cur_min);
        }
    }
    
    void pop() {
        rec.pop();
        min.pop();
    }
    
    int top() {
        return rec.top();
    }
    
    int getMin() {
        return min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```



### 12.3 字符串解码

<img src="hot100记录.assets/image-20240327133721314.png" alt="image-20240327133721314" style="zoom:80%;" />

主要考察操作逻辑：

+ 遇到`[`、数字、字母，直接入栈
+ 遇到`]`，
  + 先通过不断出栈获得字符串（直到遇到`[`，注意字符串需要逆序，当然也可以之后反着放回栈中）
  + 在通过不断出栈获得上一步获得的字符串需要重复的次数

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); i++){
            if( s[i] == '[' ||
                (s[i] >= 'a' && s[i] <= 'z') ||
                (s[i] >= '0' && s[i] <= '9')
            ){
                st.push(s[i]);
            }
            else{
                string tmp;
                while(st.top() != '['){
                    tmp.push_back(st.top());
                    st.pop();
                }
                reverse(tmp.begin(), tmp.end());
                // 弹出'['
                st.pop();
                
                // 提取数字
                int times = 0;
                int p = 1;
                // 直到st为空，或遇到不是数字的元素为止
                while(!st.empty() && st.top() >= '0' && st.top() <= '9'){
                    times = times + p * (st.top() - '0');
                    p = p * 10;
                    st.pop();
                }

                // 解码后的字符串放回
                for(int j = 0; j < times; j++){
                    for(int k = 0; k < tmp.size(); k++){
                        st.push(tmp[k]);
                    }
                }
            }
        }
        string res;
        while(!st.empty()){
            res.push_back(st.top());
            st.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



### 12.4 每日温度

<img src="hot100记录.assets/image-20240327134328175.png" alt="image-20240327134328175" style="zoom:80%;" />

典型的单调栈的问题，寻找数组元素右边第一个大于其本身的数。

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 单调栈 维护一个从栈顶到栈底单调递增的单调栈
        stack<int> st;
        vector<int> res(temperatures.size(), 0);
        for(int i = 0; i < temperatures.size(); i++){
            // 栈空或者当前数字小于等于栈顶元素，则入栈
            if(st.empty() || temperatures[i] <= temperatures[st.top()]){
                st.push(i);
            }
            else{
                // 弹出栈顶元素，直到栈空或者栈顶元素大于当前元素
                while(!st.empty() && temperatures[i] > temperatures[st.top()]){
                    int day = st.top();
                    st.pop();
                    res[day] = i - day;
                }
                st.push(i);
            }
        }
        return res;
    }
};
```

上面的代码可以再简化一下，但是不容易看出代码逻辑

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 单调栈 维护一个从栈顶到栈底单调递增的单调栈
        stack<int> st;
        vector<int> res(temperatures.size(), 0);
        for(int i = 0; i < temperatures.size(); i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){
                int day = st.top();
                st.pop();
                res[day] = i - day;
            }
            st.push(i);
        }
        return res;
    }
};
```



### 12.5 柱状图中最大的矩形

<img src="hot100记录.assets/image-20240327135756663.png" alt="image-20240327135756663" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240327135811342.png" alt="image-20240327135811342" style="zoom:80%;" />

依旧是利用单调栈解决

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 寻找每个矩形左边第一个小于本身的矩形位置
        // 若不存在，则记为-1
        stack<int> st;
        vector<int> left(heights.size(), -1);
        for(int i = heights.size() - 1; i >= 0; i--){
            if(st.empty() || heights[i] >= heights[st.top()]){
                st.push(i);
            }
            else{
                while(!st.empty() && heights[i] < heights[st.top()]){
                    int cur = st.top();
                    st.pop();
                    left[cur] = i;
                }
                st.push(i);
            }
        }

        // 寻找每个矩形右边第一个小于本身的矩形位置
        // 若不存在，则记为height.size()
        st = stack<int>();
        vector<int> right(heights.size(), heights.size());
        for(int i = 0; i < heights.size(); i++){
            if(st.empty() || heights[i] >= heights[st.top()]){
                st.push(i);
            }
            else{
                while(!st.empty() && heights[i] < heights[st.top()]){
                    int cur = st.top();
                    st.pop();
                    right[cur] = i;
                }
                st.push(i);
            }
        }     

        // 计算每个矩形可以往外扩展的面积
        int res = 0;
        for(int i = 0; i < heights.size(); i++){
            res = max(res, heights[i] * (right[i] - left[i] - 1));
        }  
        return res;
    }
};
```



## 13 堆



### 13.1 数组中的第K个最大元素

<img src="hot100记录.assets/image-20240327140416833.png" alt="image-20240327140416833" style="zoom:80%;" />

直接用单调队列即可解决

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> que;
        for(int i = 0; i < nums.size(); i++){
            if(que.size() < k){
                que.push(nums[i]);
            }
            else if(nums[i] > que.top()){
                que.pop();
                que.push(nums[i]);
            }
        }
        return que.top();
    }
};
```



### 13.2 前K个高频元素

<img src="hot100记录.assets/image-20240327140608597.png" alt="image-20240327140608597" style="zoom:80%;" />

思路和上一题相同，只是需要多申请一个`unordered_map`来记录每个元素出现的次数

```c++
class Solution {
public:
	// 自定义cmp函数
    struct cmp{
        bool operator ()(const pair<int, int>& a, const pair<int, int>& b){
            return a.second > b.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        // 统计不同元素出现次数
        for(int i = 0; i < nums.size(); i++){
            map[nums[i]]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> que;
        for(auto& cur : map){
            if(que.size() < k){
                que.push(cur);
            }
            else if(cur.second > que.top().second){
                que.pop();
                que.push(cur);
            }
        }
        vector<int> res;
        for(int i = 0; i < k; i++){
            res.push_back(que.top().first);
            que.pop();
        }
        return res;
    }
};
```



### 13.3 数据流的中位数

<img src="hot100记录.assets/image-20240327140818159.png" alt="image-20240327140818159" style="zoom:80%;" />

思路来自力扣官方题解，根据注释整理思路

```c++
class MedianFinder {
public:
    // 维护一个大顶堆leMid 用于记录小于等于中位数的元素
    priority_queue<int, vector<int>, less<int>> leMid;
    // 维护一个小顶堆gMid 用于记录大于中位数的元素
    priority_queue<int, vector<int>, greater<int>> gMid;
    // 此时需要维护以下关系中的一个
    // s1 leMid.size() == gMid.size()
    // s2 leMid.size() == gMid.size() + 1
    
    MedianFinder() {

    }
    
    void addNum(int num) {
        // 如果leMid为空或者num小于中位数，则先加入leMid
        if(leMid.empty() || num <= leMid.top()){
            leMid.push(num);
            // 观察s1或者s2是否成立，并进行相应的维护
            if(leMid.size() > gMid.size() + 1){
                int tmp = leMid.top();
                leMid.pop();
                gMid.push(tmp);
            }
        }
        else{
            gMid.push(num);
            // 观察s1或者s2是否成立，并进行相应的维护
            if(gMid.size() > leMid.size()){
                int tmp = gMid.top();
                gMid.pop();
                leMid.push(tmp);
            }
        }  
        
    }
    
    double findMedian() {
        if(leMid.size() == gMid.size())
            return (leMid.top() + gMid.top()) / 2.0;
        else 
            return leMid.top();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



## 14 贪心



### 14.1 买卖股票的最佳时机

<img src="hot100记录.assets/image-20240327141303071.png" alt="image-20240327141303071" style="zoom:80%;" />

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // minprice用于动态记录历史最低值
        // 遍历计算股票在历史最低值买入，在当前日期卖出的利润
        int minprice = INT_MAX, maxpro = 0;
        for(int i = 0; i < prices.size(); i++){
            maxpro = max(maxpro, prices[i] - minprice);
            minprice = min(minprice, prices[i]);
        }
        return maxpro;
    }
};
```



### 14.2 跳跃游戏

<img src="hot100记录.assets/image-20240327141429324.png" alt="image-20240327141429324" style="zoom:80%;" />

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 1) return true;
        
        // len 动态记录当前可以到达的最远距离
        int len = nums[0];
        for(int i = 0; i < nums.size() && i <= len; i++){
            len = max(len, i + nums[i]);
            // 当前可到达距离已经覆盖nums.size() - 1，则直接返回true
            if(len >= nums.size() - 1) return true;
        }
        return false;
    }
};
```



### 14.3 跳跃游戏II

<img src="hot100记录.assets/image-20240327141643603.png" alt="image-20240327141643603" style="zoom:80%;" />

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;

        // len记录当前这一步能到达的最远距离，初始化为0很妙啊！！！！！！！！！
        int len = 0, res = 0;
        // nextlen动态更新下一步能到达的最远距离
        int nextlen = 0;
        for(int i = 0; i <= len && i < nums.size() - 1; i++){
            if(i + nums[i] > len){
                nextlen = max(nextlen, i + nums[i]);
            }
            if(i == len){
                res ++;
                len = nextlen;
                if(len >= nums.size() - 1) break;
            }
        }

        return res;
    }
};
```



### 14.4 划分字母区间

<img src="hot100记录.assets/image-20240327142738730.png" alt="image-20240327142738730" style="zoom:80%;" />

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        // 存储每个字母最后出现的位置
        vector<int> lastIdx(26, -1);
        for(int i = 0; i < s.size(); i++){
            lastIdx[s[i] - 'a'] = max(lastIdx[s[i] - 'a'], i);
        }

        // left，right分别记录当前区间的左右端点
        int left = 0, right = 0;
        vector<int> res;
        for(int i = 0; i < s.size(); i++){
            // 更新right
            right = max(right, lastIdx[s[i] - 'a']);
            // 如果i指向right，说明当前的[left, right]是符合条件的区间
            if(i == right){
                res.push_back(right - left + 1);
                left = right + 1;
            }
        }
        return res;
    }
};
```



## 15 动态规划

动态规划的关键：

+ `dp`数组的含义
+ `dp`数组的状态转移
+ `dp`数组的初始化

### 15.1 爬楼梯

<img src="hot100记录.assets/image-20240327143056986.png" alt="image-20240327143056986" style="zoom:80%;" />

```c++
class Solution {
public:
    int climbStairs(int n) {
        // dp[i]：到达第i阶台阶有多少种方法
        vector<int> dp(n + 1, 1);
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
};
```



### 15.2 杨辉三角

<img src="hot100记录.assets/image-20240327143236376.png" alt="image-20240327143236376" style="zoom:80%;" />

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        for(int i = 0; i < numRows; i++){
            vector<int> cur;
            cur.push_back(1);
            for(int j = 1; j < i; j++){
                cur.push_back(res[i - 1][j - 1] + res[i - 1][j]);
            }
            if(i >= 1) cur.push_back(1);
            res.push_back(cur);
        }
        return res;
    }
};
```



### 15.3 打家劫舍

<img src="hot100记录.assets/image-20240327143401598.png" alt="image-20240327143401598" style="zoom:80%;" />

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<vector<int>> dp(nums.size(), vector<int>(2, 0));
        // dp[i][0] 表示今晚不偷第i家，dp[i][1]表示今晚偷第i家
        dp[0][0] = 0, dp[0][1] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            // 若不偷i，则i-1可偷可不偷
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            // 若偷i，则i-1不能偷
            dp[i][1] = dp[i - 1][0] + nums[i];
        }

        return max(dp.back()[0], dp.back()[1]);
    }
};
```



### 15.4 完全平方数

<img src="hot100记录.assets/image-20240327163422081.png" alt="image-20240327163422081" style="zoom:80%;" />

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0, dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j * j <= i; j++){
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
};
```



### 15.5 零钱兑换

<img src="hot100记录.assets/image-20240327163833165.png" alt="image-20240327163833165" style="zoom:80%;" />

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;

        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int j = 0; j < coins.size(); j++){
                // 若dp[i - coins[j]] == INT_MAX)表示使用当前的coin的数值无法组成i - coins[j]
                if(i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX){
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        if(dp.back() == INT_MAX) return -1;
        else return dp.back();
    }
};
```



```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 0; i < coins.size(); i++){
            for(int j = 0; j <= amount; j++){
                if(j - coins[i] >= 0 && dp[j - coins[i]] != INT_MAX){
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        if(dp[amount] == INT_MAX){
            return -1;
        }
        return dp[amount];
    }
};
```



### 15.6 单词拆分

<img src="hot100记录.assets/image-20240327163951949.png" alt="image-20240327163951949" style="zoom:80%;" />

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;

        for(int i = 1; i <= s.size(); i++){
            for(int j = 0; j < wordDict.size(); j++){
                if(i >= wordDict[j].size()){
                    string tmp = s.substr(i - wordDict[j].size(), wordDict[j].size());
                    if(tmp.compare(wordDict[j]) == 0){
                        dp[i] = dp[i] || dp[i - wordDict[j].size()];
                    }
                }
            }
        }
        return dp.back();
    }
};
```

上述代码中的`tmp.compare(wordDict[j])`：

+ 若`tmp < wordDict[j] `，返回一个负数
+ 若`tmp == wordDict[j] `，返回0

+ 若`tmp > wordDict[j] `，返回一个正数

C++中`string`对象的大小比较：

两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇`\0`为止。

当两个数的位数一样，则直接可以应用字符串的比较。如

```c++
"1346" > "1111" == true
```



### 15.7 最长递增子序列

<img src="hot100记录.assets/image-20240328184328018.png" alt="image-20240328184328018" style="zoom:80%;" />

> 动态规划做法

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // dp[i] 以nums[i]结尾的最长递增子序列的长度
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for(int i = 1; i < nums.size(); i++){
            // 遍历之前的元素，看nums[i]是否可以接在之前的元素后面
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};
```



> 贪心+二分查找

上面第二层`for`循环其实有一些遍历过程是冗余的，下面以序列`[3, 2, 1, 4, 5, 67]`距离：

遍历到`4`时，需要遍历之前的元素`3, 2, 1`，但是若`4`可以接在`3`后面，那么一定可以接在`1`后面，因此只需要开辟一个数组`record`，`record[i]`表示能组成长度为`i`的子序列的序列中，结尾元素的最小值，在此处，即`record[1] == 1`，则遍历到`4`时，仅需一次查询，即可确定目前`record[2] == 4`

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> record(nums.size() + 1, 0);
        int res = 0;
        for(int i = 0; i < nums.size(); i++){
            int l = 0, r = res;
            // 通过二分查找确定nums[i]可以接在哪个元素后面
            while(l < r){
                int mid = (l + r + 1) >> 1;
                if(record[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            res = max(res, l + 1);
            record[l + 1] = nums[i];
        }
        return res;
    }
};
```



### 15.8 乘积最大子数组

<img src="hot100记录.assets/image-20240328185843950.png" alt="image-20240328185843950" style="zoom:80%;" />

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        
        // dp[i][0] 记录以nums[i]结尾的数组乘积为正数时的最大值
        // dp[i][1] 记录以nums[i]结尾的数组乘积为负数时的最小值
        vector<vector<int>> dp(nums.size(), vector<int>(2, 0));
        if(nums[0] > 0) dp[0][0] = nums[0];
        else if(nums[0] < 0) dp[0][1] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            if(nums[i] > 0){
                dp[i][0] = max(dp[i - 1][0] * nums[i], nums[i]);
                dp[i][1] = dp[i - 1][1] * nums[i];
            }
            else if(nums[i] < 0){
                dp[i][0] = dp[i - 1][1] * nums[i];
                dp[i][1] = min(dp[i - 1][0] * nums[i], nums[i]);
            }
        }
        int res = 0;
        for(int i = 0; i < nums.size(); i++){
            res = max(res, dp[i][0]);
        }
        return res;
    }
};
```

利用滚动数组进行空间优化（实际上机建议写上面那种，不容易出错）

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        
        vector<int> dp(2, 0);
        if(nums[0] > 0) dp[0] = nums[0];
        else if(nums[0] < 0) dp[1] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.size(); i++){
            if(nums[i] > 0){
                dp[0] = max(dp[0] * nums[i], nums[i]);
                dp[1] = dp[1] * nums[i];
            }
            else if(nums[i] < 0){
                int tmp = dp[0];
                dp[0] = dp[1] * nums[i];
                // 直接写成dp[1] = min(dp[0] * nums[i], nums[i]);会发生错误
                // 因为上一步dp[0]进行了更新，所以需要一个变量tmp先记录dp[0]的值
                dp[1] = min(tmp * nums[i], nums[i]);
            }
            else{
                dp[0] = dp[1] = 0;
            }
            res = max(res, dp[0]);
        }

        return res;
    }
};
```



### 15.9 分割等和子集

<img src="hot100记录.assets/image-20240328190405674.png" alt="image-20240328190405674" style="zoom:80%;" />

转换成01背包问题：物品的价值和重量等值，能够装满容量为物品总重一半的背包

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++)
            sum += nums[i];
        // 若总和为奇数，则一定无法等分，直接返回false
        if(sum & 1) return false;

        int target = sum >> 1;
        vector<bool> dp(target + 1, false);
        dp[0] = true;
        // 01背包一定需要先遍历物品，再遍历背包
        for(int i = 0; i < nums.size(); i++){
            // 一个物品只能用一次，需要从后往前遍历背包
            for(int j = dp.size() - 1; j > 0; j--){
                if(j >= nums[i]){
                    dp[j] = dp[j] || dp[j - nums[i]];
                }
            }
        }
        return dp.back();
    }
};
```



### 15.10 最长有效括号

<img src="hot100记录.assets/image-20240328190737230.png" alt="image-20240328190737230" style="zoom:80%;" />

感觉之前做这题全靠的是特例报错，然后修补对未考虑情况的判断。

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        vector<int> dp(s.size(), 0);
        for(int i = 0; i < s.size(); i++){
            if(s[i] == '(') continue;
            if(i - 1 >= 0){
                // 如果s[i - 1] == '('，说明序列是******()的形式
                // 需要考虑是否可以与s[i - 2]拼接
                if(s[i - 1] == '('){
                    if(i - 2 >= 0)
                        dp[i] = dp[i - 2] + 2;
                    else dp[i] = 2;
                }
                // 此时序列是************))的形式
                // 需要往前定位到最近的可能与s[i]凑成(*********))的位置
                else if(i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '('){
                    // 考虑是否可以与之前的合法序列拼接
                    if(i - dp[i - 1] - 2 >= 0)
                        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2;
                    else
                        dp[i] = dp[i - 1] + 2;
                }
                
            }
        }
        int res = 0;
        for(int i = 0; i < s.size(); i++)
            res = max(res, dp[i]);
        return res;
    }
};
```



## 16 多维动态规划



### 16.1 不同路径

<img src="hot100记录.assets/image-20240328191743293.png" alt="image-20240328191743293" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240328191755771.png" alt="image-20240328191755771" style="zoom:80%;" />

常规题

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for(int i = 0; i < n; i++) dp[0][i] = 1;
        for(int i = 0; i < m; i++) dp[i][0] = 1;

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                 dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



### 16.2 最小路径和

<img src="hot100记录.assets/image-20240328191844280.png" alt="image-20240328191844280" style="zoom:80%;" />

思路与上一题类似，只不过从路径数量变成了路径和

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), INT_MAX));
        dp[0][0] = grid[0][0];
        for(int i = 0; i < grid.size(); i++){
            for(int j = 0; j < grid[0].size(); j++){
                if(i == 0 && j == 0) continue;
                if(j - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);
                if(i - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);
            }
        }
        return dp.back().back();
    }
};
```



### 16.3 最长回文子串

<img src="hot100记录.assets/image-20240328192140784.png" alt="image-20240328192140784" style="zoom:80%;" />

`dp[i][j] == true`表示`s[i] - s[j]`组成的字符串是回文串

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        for(int i = 0; i < s.size(); i ++){
            dp[i][i] = true;
        }
        for(int j = 1; j < s.size(); j++){
            // i需要从后往前遍历，有一个逻辑顺序
            // 如果从前往后遍历，i-j(不包括i j)还未进行回文判断就默认是回文了
            for(int i = j - 1; i >= 0; i--){
                if(s[i] == s[j]){
                    if(i == j - 1) dp[i][j] = true;
                    else if(dp[i + 1][j - 1]) dp[i][j] = true;
                }
            }
        }

        int recI = 0, recJ = 0;
        for(int j = 0; j < s.size(); j++){
            for(int i = 0; i <= j; i++){
                if(dp[i][j]){
                    if(j - i > recJ - recI)
                        recI = i, recJ = j;
                }
            }
        }
        return s.substr(recI, recJ - recI + 1);
    }
};
```



### 16.4 最长公共子序列

<img src="hot100记录.assets/image-20240328192642151.png" alt="image-20240328192642151" style="zoom:80%;" />

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size(), len2 = text2.size();
        // 注意此时元素下标从1开始
        // dp[i][j] 表示text1 1-i, text2 1-j中的最长公共子序列长度
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        
        for(int i = 1; i < dp.size(); i++){
            for(int j = 1; j < dp[0].size(); j++){
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                if(text1[i - 1] == text2[j - 1]){
                    dp[i][j] = max(dp[i - 1][j - 1] + 1, dp[i][j]);
                }
            }
        }
        return dp[len1][len2];
    }
};
```

上面代码其实做了简化，如果要考虑具体逻辑，看下面的代码：

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size(), len2 = text2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for(int i = 1; i < dp.size(); i++){
            for(int j = 1; j < dp[0].size(); j++){
                if(text1[i - 1] == text2[j - 1]){
                    dp[i][j] = max({dp[i - 1][j - 1] + 1, dp[i - 1][j], dp[i][j - 1]});
                }
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[len1][len2];
    }
};
```



### 16.5 编辑距离

<img src="hot100记录.assets/image-20240328193227844.png" alt="image-20240328193227844" style="zoom:80%;" />

思路和上一题其实差不多

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size(), len2 = word2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for(int i = 1; i <= len1; i++) dp[i][0] = i;
        for(int i = 1; i <= len2; i++) dp[0][i] = i;

        for(int i = 1; i < dp.size(); i++){
            for(int j = 1; j < dp[0].size(); j++){
                if(word1[i - 1] == word2[j - 1]){
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
                else{
                    dp[i][j] = min({dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[len1][len2];
    }
};
```

简化版本（？好像没简化多少）

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size(), len2 = word2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for(int i = 1; i <= len1; i++) dp[i][0] = i;
        for(int i = 1; i <= len2; i++) dp[0][i] = i;

        for(int i = 1; i < dp.size(); i++){
            for(int j = 1; j < dp[0].size(); j++){
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                if(word1[i - 1] == word2[j - 1]){
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j]);
                }
                else{
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i][j]);
                }
            }
        }
        return dp[len1][len2];
    }
};
```



## 17 技巧

这一部分都是奇思妙想说实话

### 17.1 只出现一次的数字

<img src="hot100记录.assets/image-20240328193555762.png" alt="image-20240328193555762" style="zoom:80%;" />

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        // 两个相等的数位运算异或为0
        // 只需要将所有数进行异或位运算，留下的数即为出现一次的数
        int x = 0;
        for(int num: nums){
            x ^= num;
        }
        return x;
    }
};
```



### 17.2 多数元素

<img src="hot100记录.assets/image-20240328193715705.png" alt="image-20240328193715705" style="zoom:80%;" />

> 个人思路

总数为 $n$，出现次数大于 $n / 2$，那只能有一个，所以找出现次数最多的那个数就行了

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> count;
        int res = 0;
        int cnt = 0;
        for(auto num: nums){
            count[num] ++;
            if(count[num] > cnt){
                res = num;
                cnt = count[num];
            }
        }
        return res;
    }
};
```



### 17.3 颜色分类

<img src="hot100记录.assets/image-20240328194112088.png" alt="image-20240328194112088" style="zoom:80%;" />

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 感觉像双指针法的扩展 -- 三指针
        int p0 = 0, p2 = nums.size() - 1;
        for(int i = 0; i < nums.size(); i++){
            // 这个while循环保证了当nums[i] == 0时，i之前的元素中不再含有2
            // 把2全移到后面
            while(i <= p2 && nums[i] == 2){
                swap(nums[p2--], nums[i]);
            }
            
            if(nums[i] == 0){
                swap(nums[p0 ++], nums[i]);
            }
        }
    }
};
```



### 17.4 下一个排列

<img src="hot100记录.assets/image-20240328194258757.png" alt="image-20240328194258757" style="zoom:80%;" />

<img src="hot100记录.assets/image-20240328194308950.png" alt="image-20240328194308950" style="zoom:80%;" />

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int idx = nums.size() - 2;
        // 找到从后往前第一个不是升序的位置
        while(idx >= 0 && nums[idx] >= nums[idx + 1])
            idx--;

        if(idx >= 0){
            int idx2 = nums.size() - 1;
            // 在nums[idx]后面找大于nums[idx]的最小的数
            while(idx2 > idx && nums[idx2] <= nums[idx])
                idx2--;
            swap(nums[idx], nums[idx2]);
        }
        reverse(nums.begin() + idx + 1, nums.end());
    }
};
```

感觉主要是手动模拟找下一个排列的过程，然后写成代码，下面以找`[3, 2, 1, 5, 7, 6, 5, 1]`的下一个排列为例：

+ 从后往前找第一个不是升序的位置：`[..., 5, 7, 6, 5, 1]`的第一个`5`
+ 找到上面这个`5`后面大于`5`的第一个数 --> `6`
+ 将两数交换`[..., 6, 7, 5, 5, 1]`
+ 将`6`后面的数逆序 --> `[..., 6, 1, 5, 5, 7]`即为符合条件的序列



### 17.5 寻找重复数

<img src="hot100记录.assets/image-20240328195056199.png" alt="image-20240328195056199" style="zoom:80%;" />

有点类似之前有环链表找环的入口，如果可以理解利用数组来模拟链表的方法，对思路的理解应该不会很困难

`nums[i]`表示`i`的下一个节点为`nums[i]`，如果存在相同的`nums[i], nums[j]`，则会有两个节点的下一个节点是相同的，即成环了

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0], fast = nums[nums[0]];
        while(slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int cur = 0;
        while(cur != slow){
            cur = nums[cur];
            slow = nums[slow];
        }
        return cur;
    }
};
```

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        while(!slow || slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        int cur = 0;
        while(cur != slow){
            cur = nums[cur];
            slow = nums[slow];
        }
        return cur;
    }
};
```

