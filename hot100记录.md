# LeetCode hot100



## 1 哈希

### 1.1 两数之和

<img src="hot100记录.assets\image-20240323094525949.png" alt="image-20240323094525949" style="zoom:80%;" />

使用哈希表记录已经访问过的数值`nums[i]`和下标`i`的映射关系，每新访问一个数值，就在哈希表中查询是否存在与其相加和为`target`的记录。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++){
            // 查看是否遍历过目标值
            auto t = map.find(target - nums[i]);
            if(t != map.end()){
                return {t->second, i};
            }
            map.insert({nums[i], i});
        }
        return {};
    }
};
```

> `unordered_map`常见用法（后续补充）

1. `find`：返回一个迭代器，指向查找到的元素。如果指定的键不存在，`find`函数返回的迭代器等于`end()`

```c++
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> my_map = {
        {1, "one"},
        {2, "two"},
        {3, "three"}
    };

    auto it = my_map.find(2);
    if (it != my_map.end()) {
        std::cout << "The value of key 2 is " << it->second << std::endl;
    } else {
        std::cout << "Key 2 not found" << std::endl;
    }

    it = my_map.find(4);
    if (it != my_map.end()) {
        std::cout << "The value of key 4 is " << it->second << std::endl;
    } else {
        std::cout << "Key 4 not found" << std::endl;
    }

    return 0;
}

```

运行上面的程序，输出结果为

```
The value of key 2 is two
Key 4 not found
```

2. `count`：返回值为找到的元素的个数

在`unordered_map`中，存在元素则返回`1`，反之，返回`0`

```c++
 unordered_map<int,int> map;
 map[0]=1;
 if((map.count(0))
 printf("这个map中含有键为1的键值对");
```



### 1.2 字母异位词分组

<img src="hot100记录.assets\image-20240323100425299.png" alt="image-20240323100425299" style="zoom:80%;" />

将字符串按照字典序排序之后的结果作为索引，并将该索引对应一个记录具有相同索引的字符串数组。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        unordered_map<string, vector<string>> map;
        for(auto str: strs){
            string tmp = str;
            // 对str升序排序，获取对应的索引
            sort(tmp.begin(), tmp.end());
            // 在索引对应的字符串数组中增加该str
            map[tmp].push_back(str);
        }

        vector<vector<string>> ans;
        for(auto kk = map.begin(); kk != map.end(); kk++){
            ans.push_back(kk->second);
        }

        return ans;
    }
};
```

> `sort`的使用

需要头文件`#include <algorithm>`

默认排序为升序，可以自定义比较函数，例如，按照下面的方法可以实现对`a`降序排序：

```c++
bool cmp(int x, int y){
    return x > y;
}

sort(a.begin(), a.end(), cmp);

// 或者下面这种方式
sort(a.begin(), a.end(), greater<int>());
```



### 1.3 最长连续序列

<img src="hot100记录.assets\image-20240323101538460.png" alt="image-20240323101538460" style="zoom:80%;" />

> 官方题解

利用`unordered_set`对原`nums`数组进行去重，然后遍历所有情况

进行的剪枝操作：只有当前元素是连续序列的第一个值才进行往后遍历，使得每个元素最多遍历一次

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 构建num_set，进行去重
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            // 判断该num是否为上升序列的第一个元素，从而保证每个元素只遍历一次
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```

> 个人思路

对原数组进行排序，并去重

依次遍历所有元素，获得最大长度

```c++
class Solution {
public:   
    int longestConsecutive(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        // 对原数组进行排序
        sort(nums.begin(), nums.end());
        // 去重
        vector<int> new_nums;
        for(int i = 0; i < nums.size(); i++){
            if(!i || nums[i] != nums[i - 1])
                new_nums.push_back(nums[i]);
        }

        // 依次遍历所有元素
        int ans = 1, ans_cur = 1;
        for(int i = 1; i < new_nums.size(); i++){
            if(new_nums[i] == new_nums[i - 1] + 1){
                ans_cur++;
            }
            else{
                ans = max(ans, ans_cur);
                ans_cur = 1;
            }
        }
        ans = max(ans, ans_cur);
        return ans;
    }
};
```



## 2 双指针

### 2.1 移动零

<img src="hot100记录.assets\image-20240323102931980.png" alt="image-20240323102931980" style="zoom:80%;" />

利用快慢指针，对于快指针而言：

+ 遇到`0`，跳过
+ 遇到非`0`，将该值记录到慢指针所指下标位置，慢指针移动一位

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 利用快慢指针进行赋值
        int sp = 0; 
        for(int fp = 0; fp < nums.size(); fp++){
            // 非零则记录，零则跳过
            if(nums[fp]){
                nums[sp++] = nums[fp];
            }
        }
       // 将慢指针后续的位置全置为0
        while(sp < nums.size())
            nums[sp++] = 0;
        return;
    }
};
```



### 2.2 盛水最多的容器

<img src="hot100记录.assets\image-20240323103312630.png" alt="image-20240323103312630" style="zoom:80%;" />

<img src="E:\04刷题\刷题笔记\leetcode hot100\hot100记录.assets\image-20240323103331350.png" alt="image-20240323103331350" style="zoom:80%;" />

左右指针`l, r`位于数组的左右两端，依次移动对应高度较小的指针（`l++`或者`r--`），并记录每次移动后的容积，直到两个指针相遇。

感觉这个思路有贪心的思想，因为若移动高度较高的指针，移动后的面积肯定小于移动前的面积，但如果移动高度较小的指针，移动后的面积可能增加。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int res = 0;
        // 循环直到两个指针相遇
        while(l < r){
            // 计算当前容器面积，更新res
            res = max(res, min(height[l], height[r]) * (r - l));
            // 移动对应高度较小的指针
            if(height[l] < height[r])   
                l++;
            else
                r--;
        }
        return res;
    }
};
```



### 2.3 接雨水

<img src="hot100记录.assets\image-20240323104113234.png" alt="image-20240323104113234" style="zoom:80%;" />

> 双指针法

按列计算每个宽度为1的底能接多少雨水

从图中可以看出，每列的雨水高度取决于该列左边最高的柱子和右边最高柱子的高度的最小值。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2) return 0;
        // maxLeft[i]表示下标i左边（包括本身）的最大高度
        vector<int> maxLeft(height.size(), 0);
        // maxRight[i]表示下标i右边（包括本身）的最大高度
        vector<int> maxRight(height.size(), 0);

        maxLeft[0] = height[0];
        for(int i = 1; i < height.size(); i++)
            maxLeft[i] = max(maxLeft[i - 1], height[i]);

        maxRight[height.size() - 1] = height[height.size() - 1];
        for(int i = height.size() - 2; i >= 0; i--)
            maxRight[i] = max(maxRight[i + 1], height[i]);

        int res = 0;
        for(int i = 0; i < height.size(); i++){
            int curHeight = min(maxLeft[i], maxRight[i]);
            // 这个判断删去也可以，因为统计最大高度时包括了本身
            // 加0对最终的结果也没有影响
            if(curHeight > height[i]){
                res += curHeight - height[i];
            }
        }
        return res;
    }
};
```

> 单调栈法

<img src="hot100记录.assets\image-20240323105851338.png" alt="image-20240323105851338" style="zoom:80%;" />

维护一个从栈顶到栈底是严格递增的单调栈

+ 遇到小于栈顶元素高度的元素时，将该元素入栈，因为需要大于等于才能接雨水

  ```c++
  if(height[i] < height[st.top()]) st.push(i);
  ```

+ 遇到等于栈顶元素高度的元素时，替换栈顶元素，例如两个连着的高为2的柱子，在计算雨水体积时，需要用靠右的柱子

  ```c++
  if(height[i] == height[st.top()]){
      st.pop();
      st.push(i);
  }
  ```

+ 遇到大于栈顶元素高度的元素时，弹出栈顶元素，该元素为接雨水凹槽的底，此时剩余的栈顶元素为接雨水凹槽的左边界

  ```c++
  // while循坏，需要持续计算
  while(!st.empty() && height[i] >= height[st.top()]){
      int mid = st.top();
      st.pop();
      if(!st.empty()){
          int h = min(height[i], height[st.top()]) - height[mid];
          // 注意减1，因为需要求左右边界中间的宽度
          int w = i - st.top() - 1;
          res += h * w;
      }
  }
  st.push(i);
  ```

整合后的代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int res = 0;
        for(int i = 0; i < height.size(); i++){
            while(!st.empty() && height[i] >= height[st.top()]){
                int mid = st.top();
                st.pop();
                if(!st.empty()){
                    int h = min(height[i], height[st.top()]) - height[mid];
                    int w = i - st.top() - 1;
                    res += h * w;
                }
            }
            st.push(i);
        }
        return res;
    }
};
```



## 3 滑动窗口

### 3.1 无重复字符串的最长子串

<img src="hot100记录.assets\image-20240323125540586.png" alt="image-20240323125540586" style="zoom:80%;" />

> 个人思路

用`unordered_map`记录对应字符上一次出现的位置，若新加入的字符在之前出现过，则更新窗口左端点的位置。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // map用于记录s[i]以及其上一次出现的位置的下标
        unordered_map<char, int> map;
        // res记录最终答案，cur_res记录当前窗口长度
        int res = 0, cur_res = 0;
        for(int i = 0; i < s.size(); i++){
            // 若s[i]之前未出现，则将s[i]移动进窗口
            if(map.find(s[i]) == map.end()){
                // 当前窗口长度 +1
                cur_res++;
                map[s[i]] = i;
            }
            // 若s[i]之前出现过
            else{
                // 窗口需要更新，更新res
                res = max(res, cur_res);
                // 若s[i]上一次出现的位置不在当前窗口内，则 cur_res += 1
                // 若s[i]上一次出现的位置不在当前窗口内，则 cur_res = i - map[s[i]]
                // 那么如何判断s[i]上一次出现是否在窗口内呢？对上述两式取min即可
                cur_res = min(cur_res + 1, i - map[s[i]]);
                // 并对map[s[i]]进行更新
                map[s[i]] = i;
            }
        }
        res = max(res, cur_res);
        return res;
    }
};
```

> 官方题解

个人思路里面对更新`cur_res`的思路有点绕，我也是样例出现报错才发现需要对`s[i]`上一次出现是否在窗口内进行特判。

官方题解的思路就比较常规，用`unodered_set`来记录在窗口中的字符

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希集合，记录每个字符是否出现过
        unordered_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            }
            // 只要下一个元素未在窗口中出现，就将该元素加入窗口
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                occ.insert(s[rk + 1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }
};
```



### 3.2 找到字符串中所有字母异位词

<img src="hot100记录.assets\image-20240323132527993.png" alt="image-20240323132527993" style="zoom:80%;" />

统计出字符串`p`中各个字符的出现次数

在字符串`s`中取与字符串`p`相同长度的窗口，移动窗口，并统计窗口中各个字符出现的次数，并与字符串`p`中各个字符出现的次数作比较

```c++
class Solution {
public:
    // 词频比较函数
    bool cmpstr(int a[26], int b[26]){
        for(int i = 0; i < 26; i++){
            if(a[i] != b[i]) return false;
        }
        return true;
    }
    
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;

        if(s.size() < p.size()) return res;

        // 因为题中只含有小写字母，所以用长度为26的数组做词频统计
        int countp[26] = {0};
        int counts[26] = {0};
        for(int i = 0; i < p.size(); i++){
            countp[p[i] - 'a']++;
        }

        int len = p.size(), lens = s.size();
        int l = 0, r = -1;
        // 移动窗口右端点
        while(r < lens - 1){
            r++;
            counts[s[r] - 'a']++;
            // 保证窗口长度等于字符串p的长度
            if(r - l + 1 > len){
                counts[s[l] - 'a']--;
                l++;
            }
            if(r - l + 1 == len)
                if(cmpstr(countp, counts))
                    res.push_back(l);
        }
        return res;
    }
};
```



## 4 子串

#### 4.1 和为K的子数组

<img src="hot100记录.assets\image-20240323133806008.png" alt="image-20240323133806008" style="zoom:80%;" />

**子数组是数组中元素的连续非空序列**

+ 首先尝试了暴力枚举（超时）
+ 因为是计算连续元素的和，想到用**前缀和**，利用前缀和之后可以ac，但是耗时较长
+ 最终思路：**前缀和+哈希表**

哈希表为不同前缀和的数值与出现次数的映射，但这个方法需要保证每次只在该数之前的前缀和中搜索（边遍历边计算）：

假设`nums[1] ~ nums[6]`和`nums[1] ~ nums[9]`的前缀和都为`5`，而`nums[1] ~ nums[8]`前缀和为`8`，`target`为`3`：

+ 如果先遍历一边统计完所有的前缀和数值以及出现次数，前缀和为`5`出现了2次。在第二次遍历到`nums[8]`时，会将`res += 2`，但实际上`nums[8] ~ nums[9]`的和为`-3`，并不符合题意

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // 用前缀和+哈希表进行优化，这个方法必须保证每次只在该数之前的前缀和中搜索
        // map: 前缀和数值 --> 出现次数
        unordered_map<int, int> map;
        // 前缀和为0先初始化为1，使得第一个元素可以参与求和
        map[0] = 1;

        int res = 0;
        int pre = 0;
        for(int i = 1; i <= nums.size(); i++){
            pre += nums[i - 1];
            int target = pre - k;
            // 查看目标前缀和是否出现过
            if(map.find(target) != map.end()){
                res += map[target];
            }
            map[pre]++;
        }
        return res;
    }
};
```



### 4.2 滑动窗口最大值

<img src="hot100记录.assets\image-20240323135354008.png" alt="image-20240323135354008" style="zoom:80%;" />

**这是单调队列的一道典型题！！！！**

通过代码理解滑动窗口的思路：

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        // 需要一个双向队列来维护从队头到队尾单调非严格单调递减的单调队列
        deque<int> dq;
        // 将前k个元素进行对应的入队操作
        for(int i = 0; i < k; i++){
            while(!dq.empty() && nums[dq.back()] <= nums[i]){
                dq.pop_back();
            }
            dq.push_back(i);
        }

        for(int i = k; i < nums.size(); i++){
            result.push_back(nums[dq.front()]);
            
            // 判断是否有元素需要出队
            if(dq.front() < i - k + 1){
                dq.pop_front();
            }

            // 元素入队
            while(!dq.empty() && nums[dq.back()] <= nums[i]){
                dq.pop_back();
            }
            dq.push_back(i);
        }
        result.push_back(nums[dq.front()]);

        return result;
    }
};
```



### 4.3 最小覆盖子串

<img src="hot100记录.assets\image-20240323140134772.png" alt="image-20240323140134772" style="zoom:80%;" />

+ `i`作为窗口右端点，每次循环向右移动一位
+ `j`作为窗口的左端点，出现冗余字符串时，向右移动

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        // cntt 统计t中字符出现次数
        // snts 统计s的当前窗口中字符出现的次数
        unordered_map<char, int> cntt, cnts;
        
        for(int i = 0; i < t.size(); i++){
            cntt[t[i]]++;
        }

        string ans = "";

        // i为窗口右端点，每次循环向右移动一步
        // j为窗口左端点
        // cnt记录窗口中有效字符出现的次数
        for(int i = 0, j = 0, cnt = 0; i < s.size(); i++){
            // 添加当前字符，更新有效字符数量
            cnts[s[i]]++;
            if(cnts[s[i]] <= cntt[s[i]]) cnt++;

            // j向右移动，去除冗余字符
            while(cnts[s[j]] > cntt[s[j]]){
                cnts[s[j]]--, j++;
            }
            
			// 如果当前窗口已经完全覆盖t，更新ans
            if(cnt == t.size()){
                if(ans == "" || ans.size() > i - j + 1){
                    ans = s.substr(j, i - j + 1);
                }
            }
        }

        return ans;
    }
};
```

> 上述代码中存在一个问题，`unordered_map`访问未出现的`key`会出现什么情况：

```c++
unordered_map<string, int> mymap1;  
auto val = mymap1["str"]; // val为0   

// 常用于词频统计，存在则加一，不存在则创建后赋值为1 
unordered_map<string, int> mymap2;  
mymap2["str"]++; // mymap2["str"] = 1   
```

Map中使用方括号访问键对应的值`map[key]`时：

+ 若该`key`存在，则访问取得`value`值；

+ 若该`key`不存在，访问仍然成功，取得`value`对象默认构造的值。具体如下：

  用` []`访问，但`key`不存在时，**C++会利用该`key`及默认构造的`value`，组成`{key，value}`对，插入到`map`中**。

  `value`为 `string`对象，则构造空串；`value`为`int`对象，构造为`0`。

注：因此在访问`map`元素时，应先用`map.find`查找该元素，找到后再访问。 同时，用法`mymap2["str"]++;`常用于词频统计，存在则加一，不存在则创建后赋值为`1`。

